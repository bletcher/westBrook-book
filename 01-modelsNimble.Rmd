## Flow model {#modelNimble}

```{r globalModelsNimble, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```


```{r librariesModelsNimble, echo = FALSE}
library(getWBData)
library(tidyverse)
library(lubridate)
library(kableExtra)
library(GGally)
library(nimble)
library(MCMCvis)
```

```{r}

```


### Read in data
```{r}
load('./models/dataOut/eh_20022003200420052006_wb obear.RData')
```

### run model phi_p 
```{r phi_p, cache=TRUE}
# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html

y <- eh$eh

hmm.phi_p <- nimbleCode({
  phi ~ dunif(0, 1) # prior survival
  p ~ dunif(0, 1) # prior detection
  # likelihood
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
  omega[1,2] <- p        # Pr(alive t -> detected t)
  omega[2,1] <- 1        # Pr(dead t -> non-detected t)
  omega[2,2] <- 0        # Pr(dead t -> detected t)
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
  
first <- apply(y, 1, function(x) min(which(x !=0)))

my.constants <- list(N = nrow(y), 
                     T = ncol(y), 
                     first = first)

my.data <- list(y = y + 1)

zinits <- y + 1 # non-detection -> alive
zinits[zinits == 2] <- 1 # dead -> alive
initial.values <- function() list(phi = runif(1,0,1),
                                  p = runif(1,0,1),
                                  z = zinits)


parameters.to.save <- c("phi", "p", "z")  
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2

start <- Sys.time()
mcmc.phi_p <- nimbleMCMC(code = hmm.phi_p, 
                        constants = my.constants,
                        data = my.data,              
                        inits = initial.values,
                        monitors = parameters.to.save,
                        niter = n.iter, 
                        nburnin = n.burnin, 
                        nchains = n.chains,
                        WAIC = TRUE)
end <- Sys.time()
elapsed_phi_p <- end - start

MCMCsummary(object = mcmc.phi_p, round = 2)
MCMCplot(object = mcmc.phi_p)

priors <- runif(3000, 0, 1)
MCMCtrace(object = mcmc.phi_p,
          ISB = FALSE,
          exact = TRUE, 
          params = c("phi", "p"),
          pdf = FALSE, 
          priors = priors)

```

### run model phiT_pT 
```{r phiT_pT, cache=TRUE}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html

y <- eh$eh

hmm.phiT_pT <- nimbleCode({
  delta[1] <- 1                    # Pr(alive t = 1) = 1
  delta[2] <- 0                    # Pr(dead t = 1) = 0
  for (t in 1:(T-1)){ # loop over time
    phi[t] ~ dunif(0, 1)           # prior survival
    gamma[1,1,t] <- phi[t]         # Pr(alive t -> alive t+1)
    gamma[1,2,t] <- 1 - phi[t]     # Pr(alive t -> dead t+1)
    gamma[2,1,t] <- 0              # Pr(dead t -> alive t+1)
    gamma[2,2,t] <- 1              # Pr(dead t -> dead t+1)
    p[t] ~ dunif(0, 1)             # prior detection
    omega[1,1,t] <- 1 - p[t]       # Pr(alive t -> non-detected t)
    omega[1,2,t] <- p[t]           # Pr(alive t -> detected t)
    omega[2,1,t] <- 1              # Pr(dead t -> non-detected t)
    omega[2,2,t] <- 0              # Pr(dead t -> detected t)
  }
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1])
    }
  }
})
  
first <- apply(y, 1, function(x) min(which(x !=0)))

my.constants <- list(N = nrow(y), 
                     T = ncol(y), 
                     first = first)

my.data <- list(y = y + 1)

zinits <- y + 1 # non-detection -> alive
zinits[zinits == 2] <- 1 # dead -> alive

initial.values <- function() list(phi = runif(my.constants$T - 1, 0, 1),
                                  p = runif(my.constants$T - 1, 0, 1),
                                  z = zinits)

parameters.to.save <- c("phi", "p")  
n.iter <- 10000
n.burnin <- 1000
n.chains <- 2

start <- Sys.time()
mcmc.phiT_pT <- nimbleMCMC(code = hmm.phiT_pT, 
                          constants = my.constants,
                          data = my.data,              
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter, 
                          nburnin = n.burnin, 
                          nchains = n.chains
                          #WAIC = TRUE
                          )
end <- Sys.time()
elapsed_phiT_pT <- end - start


MCMCsummary(object = mcmc.phiT_pT, round = 2)
MCMCplot(object = mcmc.phiT_pT)

priors <- runif(n.iter, 0, 1)
MCMCtrace(object = mcmc.phiT_pT,
          ISB = FALSE,
          exact = TRUE, 
          params = c("phi[1]", "phi[2]", "phi[3]", "phi[4]", "phi[5]", 
                     "p[1]", "p[2]", "p[3]", "p[4]", "p[5]"),
          pdf = FALSE, 
          priors = priors)


```

### run model phiT_pT_cohort 
```{r phiT_pT_cohort, cache=TRUE}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html

y <- eh$eh
nCohorts <- nrow(unique(eh$cohorts))

hmm.phiT_pT_cohort <- nimbleCode({
  delta[1] <- 1                    # Pr(alive t = 1) = 1
  delta[2] <- 0                    # Pr(dead t = 1) = 0
  
  for (i in 1:N){
    for (t in 1:(T-1)){ # loop over time
      logit(phi[t,i]) <- betaPhi[t,cohort[i]]           # prior survival
      gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
      gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
      gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
      gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
      
      logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
      omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
      omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
      omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
      omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
    }
  }
  
  
  for (c in 1:nCohorts){
    # mean values
    betaPhiCohort[c] ~ dnorm(0,1)
    betaPCohort[c] ~ dnorm(0,1)
    for (t in 1:(T-1)){ 
      betaPhi[t,c] ~ dnorm(betaPhiCohort[c], 1)
      betaP[t,c] ~ dnorm(betaPCohort[c], 1)
    }
  }
  
  # back-transform for examining output
  for (c in 1:nCohorts){
      betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
      betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
    for (t in 1:(T-1)){ 
      betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
      betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
    }
  }
  
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
      y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
    }
  }
})
  
first <- apply(y, 1, function(x) min(which(x !=0)))
cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble

my.constants <- list(N = nrow(y), 
                     T = ncol(y), 
                     first = first,
                     cohort = cohort, 
                     nCohorts = nCohorts,
                     flow = eh$flow)

my.data <- list(y = y + 1)

zinits <- y + 1 # non-detection -> alive
zinits[zinits == 2] <- 1 # dead -> alive

initial.values <- function() list(
  phi = array(runif((my.constants$T - 1) * my.constants$N, 0, 1),c((my.constants$T - 1), my.constants$N)),
  p = array(runif((my.constants$T - 1) * my.constants$N, 0, 1),c((my.constants$T - 1), my.constants$N)),
  z = zinits,
  betaPhi = array(runif((my.constants$T - 1) * nCohorts, 0, 1),c((my.constants$T - 1), nCohorts)),
  betaP = array(runif((my.constants$T - 1) * nCohorts, 0, 1),c((my.constants$T - 1), nCohorts)),
  betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
  betaPCohort = array(runif(nCohorts, 0, 1),c(nCohorts))
)

parameters.to.save <- c("betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut")  
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2

start <- Sys.time()
mcmc.phiT_pT_cohort <- nimbleMCMC(
  code = hmm.phiT_pT_cohort, 
  constants = my.constants,
  data = my.data,              
  inits = initial.values,
  monitors = parameters.to.save,
  niter = n.iter, 
  nburnin = n.burnin, 
  nchains = n.chains
  #WAIC = TRUE
)
end <- Sys.time()
elapsed_phiT_pT_cohort <- end - start


MCMCsummary(object = mcmc.phiT_pT_cohort, round = 2)
#MCMCplot(object = mcmc.phiT_pT_cohort, params = "betaPhiOut")
#MCMCplot(object = mcmc.phiT_pT_cohort, params = "betaPOut")# 
MCMCplot(object = mcmc.phiT_pT_cohort, params = c("betaPhiCohortOut"))
MCMCplot(object = mcmc.phiT_pT_cohort, params = c("betaPCohortOut"))

priors <- runif(n.iter * n.chains, 0, 1)
MCMCtrace(object = mcmc.phiT_pT_cohort,
          #ISB = FALSE,
          #exact = TRUE, 
          params = c("betaPhiCohortOut"),
          pdf = FALSE, 
          priors = priors)


```

### run model phiT_pT_cohort_flow 
#### model is preliminary  - need to get complete scaled flow matrix
```{r phiT_pT_cohort_flow, cache=TRUE}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html

y <- eh$eh
nCohorts <- nrow(unique(eh$cohorts))
nSeasons <- nrow(unique(eh$seasons))

hmm.phiT_pT_cohort_flow <- nimbleCode({
  delta[1] <- 1                    # Pr(alive t = 1) = 1
  delta[2] <- 0                    # Pr(dead t = 1) = 0
  
  for (i in 1:N){
    for (t in 1:(T-1)){ # loop over time
      logit(phi[t,i]) <- 
        betaPhi[t,cohort[i]] + 
        betaFlow[1,season[i]] * flow[i,t] +
        betaFlow[2,season[i]] * flow[i,t] * flow[i,t]
         # prior survival
      
      gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
      gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
      gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
      gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
      
      logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
      omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
      omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
      omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
      omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
    }
  }
  
  
  for (c in 1:nCohorts){
    # mean values
    betaPhiCohort[c] ~ dnorm(0,1)
    betaPCohort[c] ~ dnorm(0,1)
    for (t in 1:(T-1)){ 
      betaPhi[t,c] ~ dnorm(betaPhiCohort[c], 1)
      betaP[t,c] ~ dnorm(betaPCohort[c], 1)
    }
  }
  
  # back-transform for examining output
  for (c in 1:nCohorts){
      betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
      betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
    for (t in 1:(T-1)){ 
      betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
      betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
    }
  }
  
  for (s in 1:nSeasons){
    betaFlow[1,s] ~ dnorm(0, 1)
    betaFlow[2,s] ~ dnorm(0, 1)
  }    
  
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
      y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
    }
  }
})
  
first <- apply(y, 1, function(x) min(which(x !=0)))
cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble

my.constants <- list(N = nrow(y), 
                     T = ncol(y), 
                     first = first,
                     cohort = cohort, 
                     nCohorts = nCohorts,
                     season = eh$seasons$season,
                     flow = eh$flow)

my.data <- list(y = y + 1)

zinits <- y + 1 # non-detection -> alive
zinits[zinits == 2] <- 1 # dead -> alive

initial.values <- function() list(
  phi = array(runif((my.constants$T - 1) * my.constants$N, 0, 1),c((my.constants$T - 1), my.constants$N)),
  p =   array(runif((my.constants$T - 1) * my.constants$N, 0, 1),c((my.constants$T - 1), my.constants$N)),
  z = zinits,
  betaPhi = array(runif((my.constants$T - 1) * nCohorts, 0, 1),c((my.constants$T - 1), nCohorts)),
  betaP =   array(runif((my.constants$T - 1) * nCohorts, 0, 1),c((my.constants$T - 1), nCohorts)),
  betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
  betaPCohort =   array(runif(nCohorts, 0, 1),c(nCohorts)),
  betaFlow = array(rnorm(2 * nCohorts, 0, 1), c(2, nCohorts))
)

parameters.to.save <- c("betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut", "betaFlow")  
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2

start <- Sys.time()
mcmc.phiT_pT_cohort_flow <- nimbleMCMC(
  code = hmm.phiT_pT_cohort_flow, 
  constants = my.constants,
  data = my.data,              
  inits = initial.values,
  monitors = parameters.to.save,
  niter = n.iter, 
  nburnin = n.burnin, 
  nchains = n.chains
  #WAIC = TRUE
)
end <- Sys.time()
elapsed_phiT_pT_cohort_flow <- end - start


MCMCsummary(object = mcmc.phiT_pT_cohort_flow, round = 2)
#MCMCplot(object = mcmc.phiT_pT_cohort_flow, params = "betaPhiOut")
MCMCplot(object = mcmc.phiT_pT_cohort_flow, params = "betaFlow")# 
MCMCplot(object = mcmc.phiT_pT_cohort_flow, params = c("betaPhiCohortOut"))
MCMCplot(object = mcmc.phiT_pT_cohort_flow, params = c("betaPCohortOut"))

priors <- runif(n.iter * n.chains, 0, 1)
MCMCtrace(object = mcmc.phiT_pT_cohort_flow,
          #ISB = FALSE,
          #exact = TRUE, 
          params = c("betaPhiCohortOut"),
          pdf = FALSE, 
          priors = priors)

MCMCtrace(object = mcmc.phiT_pT_cohort_flow,
          #ISB = FALSE,
          #exact = TRUE, 
          params = c("betaFlow"),
          pdf = FALSE, 
          priors = priors)


```


### Compare models
```{r compare models}

data.frame(model = c("(phi,p)",
                     "(phit,pt)"),
           WAIC = c(mcmc.phi_p, 
                    mcmc.phiT_pT))


```

