## Flow effects on survival (phi) models - O'Bear only {#modelCMR_Flow}

The goal of this modelling exercise is to evaluate the effect of new tributary-specific stream flow estimates on survival of brook trout and brown trout. We will compare survival across the WB and tributaries with flow input data as 1) single flow estimate for all locations (historical approach) and 2) hindcasted flows for each tributary based on new tributary-specific flows which are available since 2000.

The goal is to find the best structure for the survival model, then compare survival estimates with tributary-specific flow to estimates with common flow across locations.

Structure options include
[species, cohort, season, isYOY, flow, flow^2]


```{r globalModelsNimble, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```


```{r librariesModelsNimble, echo = FALSE}
library(getWBData)
library(lubridate)
library(kableExtra)
library(GGally)
library(nimble)
library(nimbleEcology)
library(MCMCvis)
library(tidyverse)
```

```{r}
rerunSurivalModels <- FALSE
plotMCMCOutput <- TRUE
```


```{r}
#all the data
#load('./models/cmrFlowWB/dataOut/eh_2002200320042005200620072008200920102011201220132014.RData')
load('./models/cmrFlowWB/dataOut/eh_200620072008.RData')

#250 fish from each cohort
load('./models/cmrFlowWB/dataOut/eh_2002200320042005200620072008200920102011201220132014_n250.RData')

table(eh$data$cohort, eh$data$river)
```

### Model phi_p 
Single estimates of phi and p (across, time, cohorts, flow)  

#### Set up and run model
```{r phi_p_river}
# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html

if (rerunSurivalModels) {
  y <- eh$eh
  
  nSeasons <- nrow(unique(eh$seasons))
  nCohorts <- nrow(unique(eh$cohorts))
  
  hmm.phi_p <- nimbleCode({
    phi ~ dunif(0, 1) # prior survival
    p ~ dunif(0, 1) # prior detection
    # likelihood
    gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
    gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
    gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
    gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
    delta[1] <- 1          # Pr(alive t = 1) = 1
    delta[2] <- 0          # Pr(dead t = 1) = 0
    omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
    omega[1,2] <- p        # Pr(alive t -> detected t)
    omega[2,1] <- 1        # Pr(dead t -> non-detected t)
    omega[2,2] <- 0        # Pr(dead t -> detected t)
    
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):last[i]){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
        y[i,j] ~ dcat(omega[z[i,j], 1:2])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last)
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  initialValues <- function() list(phi = runif(1,0,1),
                                    p = runif(1,0,1),
                                    z = zinits
                                    )
  
  
  parametersToSave <- c("phi", "p")  
  nIter <- 5000
  nBurnin <- 1000
  nChains <- 2
  thinRate = 5
  
  start <- Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phi_p, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phi_p <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  elapsed_phi_p <- end - start
  toSave <- list(
    mcmc = mcmc.phi_p, 
    elapsed = elapsed_phi_p,
    name = "phi_p",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phi_p_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phi_p_mostRecent.RData')
  
  # output for Xioawei
  for (i in seq_along(toSave)){
    write.csv(toSave[[i]], file = paste0('./models/cmrFlowWB/runsOut/phi_p/', 
                                     names(toSave)[i], 
                                     ".csv"), 
              row.names = F)
  }
  write.csv(MCMCsummary(toSave$mcmc), file = './models/cmrFlowWB/runsOut/phi_p/mcmcSummary.csv')
  
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phi_p_mostRecent.RData')
}

if(plotMCMCOutput) {
  MCMCplot(object = toSave$mcmc)
  MCMCsummary(object = toSave$mcmc, round = 3)
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            ISB = FALSE,
            exact = TRUE, 
            params = c("phi", "p"),
            pdf = FALSE, 
            priors = priors)
}
```

### Model phiT_pT  
Phi and p vary by sampling occasion (time)  

#### Set up and run model
```{r phiT_pT_River}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nSeasons <- nrow(unique(eh$seasons))
  nCohorts <- nrow(unique(eh$cohorts))
  
  hmm.phiT_pT <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    for (t in 1:(T-1)){ # loop over time
      phi[t] ~ dunif(0, 1)           # prior survival
      gamma[1,1,t] <- phi[t]         # Pr(alive t -> alive t+1)
      gamma[1,2,t] <- 1 - phi[t]     # Pr(alive t -> dead t+1)
      gamma[2,1,t] <- 0              # Pr(dead t -> alive t+1)
      gamma[2,2,t] <- 1              # Pr(dead t -> dead t+1)
      p[t] ~ dunif(0, 1)             # prior detection
      omega[1,1,t] <- 1 - p[t]       # Pr(alive t -> non-detected t)
      omega[1,2,t] <- p[t]           # Pr(alive t -> detected t)
      omega[2,1,t] <- 1              # Pr(dead t -> non-detected t)
      omega[2,2,t] <- 0              # Pr(dead t -> detected t)
    }
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):last[i]){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last)
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  initialValues <- function() list(phi = runif(myConstants$T - 1, 0, 1),
                                    p = runif(myConstants$T - 1, 0, 1),
                                    z = zinits)
  
  parametersToSave <- c("phi", "p", "z")  
  nIter <- 5000
  nBurnin <- 1000
  nChains <- 2
  thinRate <- 5
  
  start <- Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  
  
  end <- Sys.time()
  elapsed_phiT_pT <- end - start
    toSave <- list(
      mcmc = mcmc.phiT_pT, 
      elapsed = elapsed_phiT_pT,
      name = "phiT_pT",
      myConstants = myConstants, 
      nIter = nIter, 
      nBurnin = nBurnin,
      thinRate = thinRate, 
      nSeasons = nSeasons, 
      nCohorts = nCohorts,
      nChains = nChains
    )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_mostRecent.RData')
  
  # output for Xioawei
  for (i in seq_along(toSave)){
    write.csv(toSave[[i]], file = paste0('./models/cmrFlowWB/runsOut/phiT_pT/', 
                                     names(toSave)[i], 
                                     ".csv"), 
              row.names = F)
  }
  write.csv(MCMCsummary(toSave$mcmc), file = './models/cmrFlowWB/runsOut/phiT_pT/mcmcSummary.csv')
  
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_mostRecent.RData')
}
  
if (plotMCMCOutput) {  
  MCMCplot(object = toSave$mcmc)
  MCMCsummary(object = toSave$mcmc, round = 3)

  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            #params = c("phi[1]", "phi[2]", "phi[3]", "phi[4]", "phi[5]", "phi[9]", "phi[10]",
            #           "p[1]", "p[2]", "p[3]", "p[4]", "p[5]"),
            params = c("phi"),
            pdf = FALSE, 
            priors = priors)
}

```

```{r}
#meanPost <- MCMCpstr(toSave$mcmc)
#sdPost <- MCMCpstr(toSave$mcmc, func = sd)

```


### Model phiT_pT_cohort  
Phi and p vary by time and there is a cohort effect on phi  

#### Set up and run model
```{r phiT_pT_cohort_River}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nCohorts <- nrow(unique(eh$cohorts))
  
  hmm.phiT_pT_cohort <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    
    for (i in 1:N){
      for (t in 1:(T-1)){ # loop over time
        logit(phi[t,i]) <- betaPhi[t,cohort[i]]           # prior survival
        gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
        gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
        gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
        gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
        
        logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
        omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
        omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
        omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
        omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
      }
    }
    
    
    for (c in 1:nCohorts){
      # mean values
      betaPhiCohort[c] ~ dnorm(0,1)
      betaPCohort[c] ~ dnorm(0,1)
      for (t in 1:(T-1)){ 
        betaPhi[t,c] ~ dnorm(betaPhiCohort[c], 1)
        betaP[t,c] ~ dnorm(betaPCohort[c], 1)
      }
    }
    
    # back-transform for examining output
    for (c in 1:nCohorts){
        betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
        betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
      for (t in 1:(T-1)){ 
        betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
        betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
      }
    }
    
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):last[i]){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last,
                       cohort = cohort, 
                       nCohorts = nCohorts
                       )
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  initialValues <- function() list(
    phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    p = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    z = zinits,
    betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaP = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaPCohort = array(runif(nCohorts, 0, 1),c(nCohorts))
  )
  
  parametersToSave <- c("betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut")  
  nIter <- 5000
  nBurnin <- 1000
  nChains <- 2
  thinRate = 5
  
  start <- Sys.time()
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT_cohort, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  elapsed_phiT_pT_cohort <- end - start
  
  toSave <- list(
    mcmc = mcmc.phiT_pT_cohort, 
    elapsed = elapsed_phiT_pT_cohort,
    name = "phiT_pT_cohort",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_mostRecent.RData')
}
  
if(plotMCMCOutput) { 

  MCMCplot(object = toSave$mcmc, params = c("betaPhiOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut", "betaPCohortOut"),
            pdf = FALSE, 
            priors = priors)
}

```

#### Plot phi against flow data phiT_pT_cohort
```{r plot phi and raw flow_River}
phiOut <- MCMCsummary(toSave$mcmc, params = 'betaPhiOut')


```

 


### Model phiT_pT_psi_cohort  
Phi and p vary by time and there is a cohort effect on phi  
Also include transition probabilities among rivers

#### Set up and run model
```{r phiT_pT_psiT_cohort_River}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/5_demo.html
if (rerunSurivalModels) {
  
  y <- eh$eh * eh$riverN
  (nCohorts <- nrow(unique(eh$cohorts)))
  (nSeasons <- nrow(unique(eh$seasons)))
  (nRivers <- length(unique(eh$data$riverN)))# rivers 1:4
  seasonArray <- c(3,4,1,2,3,4,1,2,3,4,1,2)
             

  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  zInitsNA <- ifelse(is.na(eh$flow), NA, 1)
  
  #  For 3 states, we are using 4
  # -------------------------------------------------
  # Parameters:
  # phiA: survival probability site A
  # phiB: survival probability site B
  # phiC: survival probability site B
  # psiAA: movement probability from site A to site A (reference)
  # psiAB = psiA[1]: movement probability from site A to site B
  # psiAC = psiA[2]: movement probability from site A to site C 
  # psiBA = psiB[1]: movement probability from site B to site A
  # psiBB: movement probability from site B to site B (reference)
  # psiBC = psiB[2]: movement probability from site B to site C
  # psiCA = psiC[1]: movement probability from site C to site A
  # psiCB = psiC[2]: movement probability from site C to site B
  # psiCC: movement probability from site C to site C (reference)
  # pA: recapture probability site A
  # pB: recapture probability site B
  # pC: recapture probability site C
  # -------------------------------------------------
  # States (z):
  # 1 alive at A
  # 2 alive at B
  # 2 alive at C
  # 3 dead
  # Observations (y):  
  # 1 not seen
  # 2 seen at A 
  # 3 seen at B
  # 3 seen at C
  # -------------------------------------------------
  
  ## model code using DHMMo distribution
  hmm.phiT_pT_psiT_CohortHierDHMM <- nimbleCode({

  delta[1] <- 0.4                    # Pr(alive t = 1 and in river 1) = 0.4
  delta[2] <- 0.2
  delta[3] <- 0.2
  delta[4] <- 0.2
  delta[5] <- 0                    # Pr(dead t = 1) = 0
    
  for (i in 1:N){
   for (t in 1:(T-1)){ # loop over time

      for (r in 1:(nRivers - 1)){
        lpsiA[r,t,i] ~ dnorm(0, sd = 1000)
        lpsiB[r,t,i] ~ dnorm(0, sd = 1000)
        lpsiC[r,t,i] ~ dnorm(0, sd = 1000)
        lpsiD[r,t,i] ~ dnorm(0, sd = 1000)
      
      # constrain the transitions such that their sum is < 1
         psiA[r,t,i] <- exp(lpsiA[r,t,i]) / (1 + exp(lpsiA[1,t,i]) + exp(lpsiA[2,t,i]) + exp(lpsiA[3,t,i]))
         psiB[r,t,i] <- exp(lpsiB[r,t,i]) / (1 + exp(lpsiB[1,t,i]) + exp(lpsiB[2,t,i]) + exp(lpsiB[3,t,i]))
         psiC[r,t,i] <- exp(lpsiC[r,t,i]) / (1 + exp(lpsiC[1,t,i]) + exp(lpsiC[2,t,i]) + exp(lpsiC[3,t,i]))
         psid[r,t,i] <- exp(lpsiD[r,t,i]) / (1 + exp(lpsiD[1,t,i]) + exp(lpsiD[2,t,i]) + exp(lpsiD[3,t,i]))
      }
     
      # last transition probability
      psiA[4,t,i] <- 1 - psiA[1,t,i] - psiA[2,t,i] - psiA[3,t,i]
      psiB[4,t,i] <- 1 - psiB[1,t,i] - psiB[2,t,i] - psiB[3,t,i]
      psiC[4,t,i] <- 1 - psiC[1,t,i] - psiC[2,t,i] - psiC[3,t,i]
      psiD[4,t,i] <- 1 - psiD[1,t,i] - psiD[2,t,i] - psiD[3,t,i]
    
      # probabilities of state z(t+1) given z(t)
      gamma[1,1,t,i] <- phiA[t,i] * psiA[1,t,i]
      gamma[1,2,t,i] <- phiA[t,i] * psiA[2,t,i]
      gamma[1,3,t,i] <- phiA[t,i] * psiA[3,t,i]
      gamma[1,4,t,i] <- phiA[t,i] * psiA[4,t,i]
      gamma[1,5,t,i] <- 1 - phiA[t,i]
      gamma[2,1,t,i] <- phiB[t,i] * psiB[1,t,i]
      gamma[2,2,t,i] <- phiB[t,i] * psiB[2,t,i]
      gamma[2,3,t,i] <- phiB[t,i] * psiB[3,t,i]
      gamma[2,4,t,i] <- phiB[t,i] * psiB[4,t,i]
      gamma[2,5,t,i] <- 1 - phiB[t,i]
      gamma[3,1,t,i] <- phiC[t,i] * psiC[1,t,i]
      gamma[3,2,t,i] <- phiC[t,i] * psiC[2,t,i]
      gamma[3,3,t,i] <- phiC[t,i] * psiC[3,t,i]
      gamma[3,4,t,i] <- phiC[t,i] * psiC[4,t,i]
      gamma[3,5,t,i] <- 1 - phiC[t,i]
      gamma[4,1,t,i] <- phiD[t,i] * psiD[1,t,i]
      gamma[4,2,t,i] <- phiD[t,i] * psiD[2,t,i]
      gamma[4,3,t,i] <- phiD[t,i] * psiD[3,t,i]
      gamma[4,4,t,i] <- phiD[t,i] * psiD[4,t,i]
      gamma[4,5,t,i] <- 1 - phiD[t,i]
      gamma[5,1,t,i] <- 0
      gamma[5,2,t,i] <- 0
      gamma[5,3,t,i] <- 0
      gamma[5,4,t,i] <- 0
      gamma[5,5,t,i] <- 1
      
      logit(phiA[t,i]) <- betaPhi[1,t,cohort[i]] 
      logit(phiB[t,i]) <- betaPhi[2,t,cohort[i]]
      logit(phiC[t,i]) <- betaPhi[3,t,cohort[i]]
      logit(phiD[t,i]) <- betaPhi[4,t,cohort[i]]

     } # t loop
    
          ## DT changes:
      ## need to pad the gamma matrix with an extra t=T row, to ensure it's
      ## always a matrix.  This values are never actually used (except maybe for internal checking of row sums = 1),
      ## but defining them is necessary.
      # for (a in 1:nRivers){
      #   for (b in 1:(nRivers - 1)){
      #     gamma[a,b,T,i] <- 0
      #     gamma[a,b,T,i] <- 0
      #     gamma[a,b,T,i] <- 0
      #     gamma[a,b,T,i] <- 0
      #  
      #   }  
      #     gamma[a,5,T,i] <- 1
      # }

     # omega for first obs      
     omega[1,1,first[i],i] <- 0     # Pr(alive A t -> non-detected t)
     omega[1,2,first[i],i] <- 1         # Pr(alive A t -> detected A t)
     omega[1,3,first[i],i] <- 0          # Pr(alive A t -> detected B t)
     omega[1,4,first[i],i] <- 0          # Pr(alive A t -> detected C t)
     omega[1,5,first[i],i] <- 0          # Pr(alive A t -> detected D t)
     omega[2,1,first[i],i] <- 0     # Pr(alive B t -> non-detected t)
     omega[2,2,first[i],i] <- 0          # Pr(alive B t -> detected A t)
     omega[2,3,first[i],i] <- 1         # Pr(alive B t -> detected B t)
     omega[2,4,first[i],i] <- 0          # Pr(alive B t -> detected C t)
     omega[2,5,first[i],i] <- 0          # Pr(alive B t -> detected C t)
     omega[3,1,first[i],i] <- 0     # Pr(alive C t -> non-detected t)
     omega[3,2,first[i],i] <- 0          # Pr(alive C t -> detected A t)
     omega[3,3,first[i],i] <- 0          # Pr(alive C t -> detected B t)
     omega[3,4,first[i],i] <- 1         # Pr(alive C t -> detected C t)
     omega[3,5,first[i],i] <- 0          # Pr(alive C t -> detected C t)
     omega[4,1,first[i],i] <- 0     # Pr(dead t -> non-detected t)
     omega[4,2,first[i],i] <- 0          # Pr(dead t -> detected A t)
     omega[4,3,first[i],i] <- 0          # Pr(dead t -> detected B t)
     omega[4,4,first[i],i] <- 0          # Pr(dead t -> detected C t)
     omega[4,5,first[i],i] <- 1          # Pr(dead t -> detected C t)
     omega[5,1,first[i],i] <- 1         # Pr(dead t -> non-detected t)
     omega[5,2,first[i],i] <- 0          # Pr(dead t -> detected A t)
     omega[5,3,first[i],i] <- 0          # Pr(dead t -> detected B t)
     omega[5,4,first[i],i] <- 0          # Pr(dead t -> detected C t)
     omega[5,5,first[i],i] <- 0          # Pr(dead t -> detected D t)
          
      ## DT changes:
      ## time t > first[i]:
      for(t in (first[i]+1):last[i]) {
        logit(pA[t,i]) <- betaP[1,t-1,cohort[i]]             # prior detection
        logit(pB[t,i]) <- betaP[2,t-1,cohort[i]]
        logit(pC[t,i]) <- betaP[3,t-1,cohort[i]]
        logit(pD[t,i]) <- betaP[4,t-1,cohort[i]]
        
        
        # probabilities of y(t) given z(t)
                           # letters are not all correct below  
        omega[1,1,t,i] <- 1 - pA[t,i]     # Pr(alive A t -> non-detected t)
        omega[1,2,t,i] <- pA[t,i]         # Pr(alive A t -> detected A t)
        omega[1,3,t,i] <- 0          # Pr(alive A t -> detected B t)
        omega[1,4,t,i] <- 0          # Pr(alive A t -> detected C t)
        omega[1,5,t,i] <- 0          # Pr(alive A t -> detected D t)
        omega[2,1,t,i] <- 1 - pB[t,i]     # Pr(alive B t -> non-detected t)
        omega[2,2,t,i] <- 0          # Pr(alive B t -> detected A t)
        omega[2,3,t,i] <- pB[t,i]         # Pr(alive B t -> detected B t)
        omega[2,4,t,i] <- 0          # Pr(alive B t -> detected C t)
        omega[2,5,t,i] <- 0          # Pr(alive B t -> detected C t)
        omega[3,1,t,i] <- 1 - pC[t,i]     # Pr(alive C t -> non-detected t)
        omega[3,2,t,i] <- 0          # Pr(alive C t -> detected A t)
        omega[3,3,t,i] <- 0          # Pr(alive C t -> detected B t)
        omega[3,4,t,i] <- pC[t,i]         # Pr(alive C t -> detected C t)
        omega[3,5,t,i] <- 0          # Pr(alive C t -> detected C t)
        omega[4,1,t,i] <- 1 - pD[t,i]     # Pr(dead t -> non-detected t)
        omega[4,2,t,i] <- 0          # Pr(dead t -> detected A t)
        omega[4,3,t,i] <- 0          # Pr(dead t -> detected B t)
        omega[4,4,t,i] <- 0          # Pr(dead t -> detected C t)
        omega[4,5,t,i] <- pD[t,i]          # Pr(dead t -> detected C t)
        omega[5,1,t,i] <- 1         # Pr(dead t -> non-detected t)
        omega[5,2,t,i] <- 0          # Pr(dead t -> detected A t)
        omega[5,3,t,i] <- 0          # Pr(dead t -> detected B t)
        omega[5,4,t,i] <- 0          # Pr(dead t -> detected C t)
        omega[5,5,t,i] <- 0          # Pr(dead t -> detected D t)
      }
      
    } # i loop
    ##    
    ## make hier across rivers
    for (r in 1:nRivers){
      betaPhiRiverCohort[r] ~ dnorm(0,1)
      betaPRiverCohort[r] ~ dnorm(0,1)
      for (c in 1:nCohorts){
          # mean values
          betaPhiCohort[r,c] ~ dnorm(betaPhiRiverCohort[r],1)
          betaPCohort[r,c] ~ dnorm(betaPhiRiverCohort[r],1)
          for (t in 1:(T-1)){ 
              betaPhi[r,t,c] ~ dnorm(betaPhiCohort[r,c],1)
              betaP[r,t,c] ~ dnorm(betaPCohort[r,c],1)
          }
      }
    }
      ##    
      # back-transform for examining output
      for (r in 1:nRivers){
        betaPhiRiverCohortOut[r] <- 1/(1 + exp(-betaPhiRiverCohort[r]))
        betaPRiverCohortOut[r] <- 1/(1 + exp(-betaPRiverCohort[r]))
        for (c in 1:nCohorts){
            betaPhiCohortOut[r,c] <- 1/(1 + exp(-betaPhiCohort[r,c]))
            betaPCohortOut[r,c] <- 1/(1 + exp(-betaPCohort[r,c]))
            for (t in 1:(T-1)){ 
                betaPhiOut[r,t,c] <- 1/(1 + exp(-betaPhi[r,t,c]))
                betaPOut[r,t,c] <- 1/(1 + exp(-betaP[r,t,c])) 
            }
        }
     } 
   
    # likelihood
    for (i in 1:N){
      y[i,first[i]:last[i]] ~ dDHMMo(init = delta[1:5],
                                     probTrans = gamma[1:5, 1:5, first[i]:last[i], i],
                                     probObs = omega[1:5, 1:5, first[i]:last[i], i],
                                     len = length[i],
                                     checkRowSums = 1)
    }
  
  })
  
  
  myConstants <- list(N = nrow(y), 
                      T = ncol(y), 
                      first = first,
                      last = last,
                      cohort = cohort, 
                      nCohorts = nCohorts,
                      season = seasonArray, 
 #                     flow = eh$flow,
                      length = last - first + 1
                      )
  
  ## DT changes:
  myData <- list(yCJS = eh$eh, #y,    ## data for CJS distribution
                 y = y + 1)   ## data for DHMM distribution
  
  
  initialValues <- function() list(
                                  betaInt = rnorm(1, 0, 1),
                                  z = zInitsNA,
                                  betaPhi = array(runif(nRivers * (myConstants$T - 1) * nCohorts, 0, 1),c(nRivers, (myConstants$T - 1), nCohorts)),
                                  betaP =   array(runif(nRivers * (myConstants$T - 1) * nCohorts, 0, 1),c(nRivers, (myConstants$T - 1), nCohorts)),
                                  betaPhiCohort = array(runif(nRivers * nCohorts, 0, 1),c(nRivers, nCohorts)),
                                  betaPCohort =   array(runif(nRivers * nCohorts, 0, 1),c(nRivers, nCohorts)),
                                  betaPhiRiverCohort = array(runif(nRivers, 0, 1),c(nRivers)),
                                  betaPRiverCohort =   array(runif(nRivers, 0, 1),c(nRivers))
                              )
  
  
  ## if you change this FALSE to TRUE
  ## this makes the dataset smaller - only 200 observations,
  ## for quicker testing
  if(FALSE) {
      newN <- 200
      oldN <- dim(y)[1]
      set.seed(0)
      indToKeep <- sample(1:oldN, size = newN, replace = FALSE)
  }
  
  ## this removes the very last observation,
  ## since first[2376] = T = 12, which is not allowed
  ## to have the first observation occur on the final sampling period
  ## for either CJS or DHMM distributions
  if(TRUE) {
      indToKeep <- which(first < 12)
      newN <- length(indToKeep)
  }
  
  myConstants <- list(
      N = newN,
      T = myConstants$T,
      first = myConstants$first[indToKeep],
      last = myConstants$last[indToKeep],
      cohort = myConstants$cohort[indToKeep],
      nCohorts = myConstants$nCohorts,
      season = myConstants$season,
      flow = myConstants$flow[indToKeep,],
      length = myConstants$length[indToKeep]
  )
  
  myData <- list(
      yCJS = myData$yCJS[indToKeep,],
      y = myData$y[indToKeep,]
  )
  
  zInitsNA <- zInitsNA[indToKeep,]
  
  set.seed(0)

  ## you'll get warnings that the data 'yCJS' is not used, and the 'z' initial
  ## values are not in the model.  Those don't cause any problems,
  ## and let us use the same myData and initialValue() for both models.
  system.time(
      Rmodel <- nimbleModel(
          code = hmm.phiT_pT_psiT_CohortHierDHMM,
          constants = myConstants,
          data = myData,              
          inits = initialValues(),
          calculate = FALSE
      )
  )
  
  Rmodel$calculate()
  ## latent state: -29141.62
  ## latent state (200 ind): -2847.746
  ## dDHMMo (200 ind): -1199.098 (same as CJS)
  ## dDHMMo (all but last observation): -1217.127 (same as CJS)
  
  parametersToSave <- c("betaPhi", "betaP", "betaPhiCohort", "betaPCohort",
                        "betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut", 
                        "betaPhiRiverCohortOut", "betaPRiverCohortOut"
)  
  
  nIter <- 20000 #30000
  nBurnin <- 10000 #15000
  nChains <- 2
  thinRate <- 5
  
  start = Sys.time()
  
  system.time(
      conf <- configureMCMC(
          Rmodel,
          monitors = parametersToSave
      )
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_psiT_CohortHierDHMM <- runMCMC(
      Cmcmc, 
      niter = nIter, 
      nburnin = nBurnin, 
      thin = thinRate, 
      nchains = nChains
  )
  
  end <- Sys.time()
  elapsed_phiT_pT_psiT_CohortHierDHMM <- end - start
  toSave <- list(
      mcmc = mcmc.phiT_pT_psiT_CohortHierDHMM, 
      elapsed = elapsed_phiT_pT_psiT_CohortHierDHMM,
      name = "phiT_pT_psiT_CohortHierDHMM",
      myConstants = myConstants, 
      nIter = nIter, 
      nBurnin = nBurnin,
      thinRate = thinRate, 
      nSeasons = nSeasons, 
      nCohorts = nCohorts,
      nChains = nChains
  )
  
    save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_psiT_CohortHierDHMM_', substr(end,1,13), '.RData'))
    save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_psiT_CohortHierDHMM_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_psiT_CohortHierDHMM_mostRecent.RData')
}

if(plotMCMCOutput) {

  #MCMCsummary(object = mcmc.phiT_pT_cohort_flowHier, round = 2)
  #MCMCplot(object = mcmc.phiT_pT_cohort_flowHier, params = "betaPhiOut")
  MCMCplot(object = toSave$mcmc, params = "betaFlowTop")
  MCMCplot(object = toSave$mcmc, params = "betaFlow")# 
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohort"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaFlowCohort"))
  
  priors <- rnorm(toSave$nIter * toSave$nChains, 0, 1/sqrt(.1))
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlowTop"),
            pdf = FALSE, 
            priors = priors)
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut"),
            pdf = FALSE, 
            priors = priors)
  
  priors <- rnorm(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlow"),
            pdf = FALSE, 
            priors = priors)
}


```












### Model phiT_pT_cohort_flow  
Add mean flow over the interval as a survival effect  

#### Set up and run model
```{r phiT_pT_cohort_flow_River}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nCohorts <- nrow(unique(eh$cohorts))
  nSeasons <- nrow(unique(eh$seasons))
  seasonArray <- c(3,4,1,2,3,4,1,2,3,4,1,2)
  
  hmm.phiT_pT_cohort_flow <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    
    for (i in 1:N){
      for (t in 1:(T-1)){ # loop over time
        logit(phi[t,i]) <- 
          betaInt +
          betaPhi[t,cohort[i]] + 
          betaFlow[1,season[t]] * flow[i,t] +
          betaFlow[2,season[t]] * flow[i,t] * flow[i,t]
           # prior survival
        
        gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
        gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
        gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
        gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
        
        logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
        omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
        omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
        omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
        omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
      }
    }
    
    betaInt ~ dnorm(0,1)
    
    for (c in 1:nCohorts){
      # mean values
      betaPhiCohort[c] ~ dnorm(0,1) #1
      betaPCohort[c] ~ dnorm(0,1) #1
      for (t in 1:(T-1)){ 
        betaPhi[t,c] ~ dnorm(betaPhiCohort[c], 1)
        betaP[t,c] ~ dnorm(betaPCohort[c], 1)
      }
    }
    
    # back-transform for examining output
    for (c in 1:nCohorts){
        betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
        betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
      for (t in 1:(T-1)){ 
        betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
        betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
      }
    }
    
    for (s in 1:nSeasons){
      betaFlow[1,s] ~ dnorm(0, 1)
      betaFlow[2,s] ~ dnorm(0, 1)
    }    
    
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):(last[i])){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last,
                       cohort = cohort, 
                       nCohorts = nCohorts,
                       season = seasonArray, #eh$seasons$season,
                       flow = eh$flow
                       )
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  zInitsNA <- ifelse(is.na(eh$flow), NA, 1)
  
  initialValues <- function() list(
    betaInt = rnorm(1, 0, 1),
    phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    p =   array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    z = zInitsNA,
    betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaP =   array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaPCohort =   array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaFlow = array(rnorm(2 * 4, 0, 1), c(2, 4))
  )
  
  parametersToSave <- c("betaInt", 
                        "betaPhi", "betaP", 
                        "betaPhiCohort", "betaPCohort",
                        "betaPhiOut", "betaPOut", 
                        "betaPhiCohortOut", "betaPCohortOut", 
                        "betaFlow")  
  nIter <- 20000
  nBurnin <- 10000
  nChains <- 2
  thinRate <- 5
  
  start = Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT_cohort_flow, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort_flow <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  
  elapsed_phiT_pT_cohort_flow <- end - start
  toSave <- list(
    mcmc = mcmc.phiT_pT_cohort_flow, 
    elapsed = elapsed_phiT_pT_cohort_flow,
    name = "phiT_pT_cohort_flow",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flow_', substr(end,1,13), '.RData'))
    save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flow_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flow_mostRecent.RData')
}
# could consider forward algo to speed up convergence (https://oliviergimenez.github.io/banana-book/hmmcapturerecapture.html#nimble-implementation-1)

if(plotMCMCOutput) {
  #MCMCsummary(object = toSave$mcmc, round = 2)
  #MCMCplot(object = mcmc.phiT_pT_cohort_flow, params = "betaPhiOut")
  MCMCplot(object = toSave$mcmc, params = "betaFlow")# 
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohort"))
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
    MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut"),
            pdf = FALSE, 
            priors = priors)
  
  priors <- rnorm(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlow"),
            pdf = FALSE, 
            priors = priors)
}
# run more iterations, if necessary
# nIterAdd <- 5000
# Cmcmc$run(nIterAdd, reset = FALSE)
# more_samples <- as.matrix(Cmcmc$mvSamples)
# 
# MCMCtrace(object = more_samples,
#           #ISB = FALSE,
#           #exact = TRUE, 
#           params = c("betaFlow"),
#           pdf = FALSE, 
#           priors = priors)

```

#### Get flow effect estimates  
Flow effects fixed across cohorts
```{r}
   #     betaInt +
   #     betaPhi[t,cohort[i]] + 
   #     betaFlow[1,season[t]] * flow[i,t] +
   #     betaFlow[2,season[t]] * flow[i,t] * flow[i,t]


getPredictionsFlow <- function(mcmc, everyNIters = 10, flowStep = 0.5){

  ## betaInt
  predictorsBetaInt <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters)
  )
  for(i in 1:nrow(predictorsBetaInt)){
    predictorsBetaInt$betaInt[i] <- mcmc$chain1[[ predictorsBetaInt[i, "iter"], "betaInt" ]]
  }
  
  
  ## betaFlow
  predictorsBetaFlow <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    season = 1:toSave$nSeasons
  )
  
  for(i in 1:nrow(predictorsBetaFlow)){
    predictorsBetaFlow$betaFlow1[i] <- mcmc$chain1[[predictorsBetaFlow[i, "iter"], 
                                                   paste0("betaFlow[1, ", predictorsBetaFlow[i, "season"],
                                                          "]")
                                                  ]]
    predictorsBetaFlow$betaFlow2[i] <- mcmc$chain1[[predictorsBetaFlow[i, "iter"], 
                                                   paste0("betaFlow[2, ", predictorsBetaFlow[i, "season"],
                                                          "]")
                                                  ]]
  }
  
  ## betaPhi
  predictorsBetaPhi <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    cohort = 1:toSave$nCohorts
  )
  for(i in 1:nrow(predictorsBetaPhi)){
    predictorsBetaPhi$betaPhi[i] <- mcmc$chain1[[predictorsBetaPhi[i, "iter"], 
                                                   paste0("betaPhiCohort[", predictorsBetaPhi[i, "cohort"],
                                                          "]")
                                                ]]
  }

  predictorsAll <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    cohort = 1:toSave$nCohorts,
    season = 1:toSave$nSeasons,
    flow = seq(-1.5, 1.5, flowStep)
  )
  
  preds <- predictorsAll %>%
    left_join(predictorsBetaInt) %>%
    left_join(predictorsBetaFlow) %>%
    left_join(predictorsBetaPhi) %>%
    mutate(predPhi = plogis(betaInt + betaPhi + betaFlow1 * flow + betaFlow2 * flow^2))
  
  return(preds)
}

predFlow <- getPredictionsFlow(toSave$mcmc, everyNIters = 2)

```

#### Plot flow predictions phiT_pT_cohort_flow
```{r}
ggplot(predFlow, aes(flow, predPhi, group = iter)) +
  geom_line(alpha = 0.025) +
  facet_grid(season ~ cohort)

# ggplot(predFlow %>% filter(season ==1, cohort == 6), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.5) +
#   facet_grid(cohort ~ season)
# 
# ggplot(predFlow %>% filter(cohort == 3), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap( ~ season)
# 
# ggplot(predFlow %>% filter(season ==1), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap(~ cohort)

```

### Model phiT_pT_cohort_flowCohort
Flow effects vary by cohort  

#### Set up and run model
```{r phiT_pT_cohort_flowCohort_River}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nCohorts <- nrow(unique(eh$cohorts))
  nSeasons <- nrow(unique(eh$seasons))
  seasonArray <- c(3,4,1,2,3,4,1,2,3,4,1,2)
  
  hmm.phiT_pT_cohort_flowCohort <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    
    for (i in 1:N){
      for (t in 1:(T-1)){ # loop over time
        logit(phi[t,i]) <- 
          betaInt +
          betaPhi[t,cohort[i]] + 
          betaFlow[1,season[t],cohort[i]] * flow[i,t] +
          betaFlow[2,season[t],cohort[i]] * flow[i,t] * flow[i,t]
           # prior survival
        
        gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
        gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
        gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
        gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
        
        logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
        omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
        omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
        omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
        omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
      }
    }
    
    betaInt ~ dnorm(0,1)
    
    for (c in 1:nCohorts){
      # mean values
      betaPhiCohort[c] ~ dnorm(0,1)
      betaPCohort[c] ~ dnorm(0,1)
      for (t in 1:(T-1)){ 
        betaPhi[t,c] ~ dnorm(betaPhiCohort[c], 1)
        betaP[t,c] ~ dnorm(betaPCohort[c], 1)
      }
    }
    
    # back-transform for examining output
    for (c in 1:nCohorts){
        betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
        betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
      for (t in 1:(T-1)){ 
        betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
        betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
      }
    }
    
    for (s in 1:nSeasons){
      for (c in 1:nCohorts){
        betaFlow[1,s,c] ~ dnorm(0, 1)
        betaFlow[2,s,c] ~ dnorm(0, 1)
      }   
    }
    
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):(last[i])){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last,
                       cohort = cohort, 
                       nCohorts = nCohorts,
                       season = seasonArray, #eh$seasons$season,
                       flow = eh$flow
                       )
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  zInitsNA <- ifelse(is.na(eh$flow), NA, 1)
  
  initialValues <- function() list(
    betaInt = rnorm(1, 0, 1),
    phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    p =   array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    z = zInitsNA,
    betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaP =   array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaPCohort =   array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaFlow = array(rnorm(2 * 4 * nCohorts, 0, 1), c(2, 4, nCohorts))
  )
  
  parametersToSave <- c("betaInt", 
                        "betaPhi", "betaP", "betaPhiCohort", "betaPCohort",
                        "betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut", 
                        "betaFlow")  
  nIter <- 20000
  nBurnin <- 10000
  nChains <- 2
  thinRate <- 5
  
  start = Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT_cohort_flowCohort, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort_flowCohort <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  
  elapsed_phiT_pT_cohort_flowCohort <- end - start
  toSave <- list(
    mcmc = mcmc.phiT_pT_cohort_flowCohort, 
    elapsed = elapsed_phiT_pT_cohort_flowCohort,
    name = "phiT_pT_cohort_flowCohort",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohort_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohort_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohort_mostRecent.RData')
}
# could consider forward algo to speed up convergence (https://oliviergimenez.github.io/banana-book/hmmcapturerecapture.html#nimble-implementation-1)

if(plotMCMCOutput) {

  #MCMCsummary(object = mcmc.phiT_pT_cohort_flow, round = 2)
  #MCMCplot(object = mcmc.phiT_pT_cohort_flow, params = "betaPhiOut")
  MCMCplot(object = toSave$mcmc, params = "betaFlow")# 
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut"),
            pdf = FALSE, 
            priors = priors)
  
  priors <- rnorm(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlow"),
            pdf = FALSE, 
            priors = priors)
}

# run more iterations, if necessary
# nIterAdd <- 5000
# Cmcmc$run(nIterAdd, reset = FALSE)
# more_samples <- as.matrix(Cmcmc$mvSamples)
# 
# MCMCtrace(object = more_samples,
#           #ISB = FALSE,
#           #exact = TRUE, 
#           params = c("betaFlow"),
#           pdf = FALSE, 
#           priors = priors)

```

#### Get flow effect estimates
Flow effects vary across cohorts
```{r}
   #     betaInt +
   #     betaPhi[t,cohort[i]] + 
   #     betaFlow[1,season[t],cohort[i]] * flow[i,t] +
   #     betaFlow[2,season[t],cohort[i]] * flow[i,t] * flow[i,t]

# load current flow model
#load("C:/Users/bletcher/OneDrive - DOI/projects/westBrook-book/models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flow_2022-05-12 10.RData")

getPredictionsFlowCohort <- function(toSave, everyNIters = 10, flowStep = 0.5){

  mcmc <- toSave$mcmc
  ## betaInt
  predictorsBetaInt <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters)
  )
  for(i in 1:nrow(predictorsBetaInt)){
    predictorsBetaInt$betaInt[i] <- mcmc$chain1[[ predictorsBetaInt[i, "iter"], "betaInt" ]]
  }
  
  
  ## betaFlow
  predictorsBetaFlow <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    season = 1:toSave$nSeasons,
    cohort = 1:toSave$nCohorts
  )
  
  for(i in 1:nrow(predictorsBetaFlow)){
    predictorsBetaFlow$betaFlow1[i] <- mcmc$chain1[[predictorsBetaFlow[i, "iter"], 
                                                   paste0("betaFlow[1, ", predictorsBetaFlow[i, "season"],
                                                          ", ",           predictorsBetaFlow[i, "cohort"],
                                                          "]")
                                                  ]]
    predictorsBetaFlow$betaFlow2[i] <- mcmc$chain1[[predictorsBetaFlow[i, "iter"], 
                                                   paste0("betaFlow[2, ", predictorsBetaFlow[i, "season"],
                                                          ", ",           predictorsBetaFlow[i, "cohort"],
                                                          "]")
                                                  ]]
  }
  
  ## betaPhi
  predictorsBetaPhi <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    cohort = 1:toSave$nCohorts
  )
  
  # this step is very slow for some reason......
  for(i in 1:nrow(predictorsBetaPhi)){
    predictorsBetaPhi$betaPhi[i] <- mcmc$chain1[[predictorsBetaPhi[i, "iter"], 
                                                   paste0("betaPhiCohort[", predictorsBetaPhi[i, "cohort"],
                                                          "]")
                                                ]]
  }

  predictorsAll <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    cohort = 1:toSave$nCohorts,
    season = 1:toSave$nSeasons,
    flow = seq(-1.5, 1.5, flowStep)
  )
  
  preds <- predictorsAll %>%
    left_join(predictorsBetaInt) %>%
    left_join(predictorsBetaFlow) %>%
    left_join(predictorsBetaPhi) %>%
    mutate(predPhi = plogis(betaInt + betaPhi + betaFlow1 * flow + betaFlow2 * flow^2))
  
  return(preds)
}

predFlowCohort <- getPredictionsFlowCohort(toSave, everyNIters = 2)

```

#### Plot flow predictions phiT_pT_cohort_flowCohort
```{r}
ggplot(predFlowCohort, aes(flow, predPhi, group = iter)) +
  geom_line(alpha = 0.025) +
  facet_grid(season ~ cohort)

# ggplot(predFlowCohort %>% filter(season ==1, cohort == 6), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.5) +
#   facet_grid(cohort ~ season)
# 
# ggplot(predFlowCohort %>% filter(cohort == 3), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap( ~ season)
# 
# ggplot(predFlowCohort %>% filter(season ==1), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap(~ cohort)

```

### Model phiT_pT_cohort_flowCohortHier
Flow effects vary by cohort, hierarchical across cohorts  

#### Set up and run model
```{r phiT_pT_cohort_flowCohortHier_River}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nCohorts <- nrow(unique(eh$cohorts))
  nSeasons <- nrow(unique(eh$seasons))
  seasonArray <- c(3,4,1,2,3,4,1,2,3,4,1,2)
  
  hmm.phiT_pT_cohort_flowCohortHier <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    
    for (i in 1:N){
      for (t in 1:(T-1)){ # loop over time
        logit(phi[t,i]) <- 
          betaInt +
          betaPhi[t,cohort[i]] + 
          betaFlow[1,season[t],cohort[i]] * flow[i,t] +
          betaFlow[2,season[t],cohort[i]] * flow[i,t] * flow[i,t]
           # prior survival
        
        gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
        gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
        gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
        gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
        
        logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
        omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
        omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
        omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
        omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
      }
    }
    
    betaInt ~ dnorm(0,1)
    betaFlowTop[1] ~ dnorm(0,0.1) # to 0.1
    betaFlowTop[2] ~ dnorm(0,0.1)
    
    for (c in 1:nCohorts){
      # mean values
      betaPhiCohort[c] ~ dnorm(0,1)
      betaPCohort[c] ~ dnorm(0,1)
      betaFlowCohort[1,c] ~ dnorm(betaFlowTop[1],1)
      betaFlowCohort[2,c] ~ dnorm(betaFlowTop[2],1)
      for (t in 1:(T-1)){ 
        betaPhi[t,c] ~ dnorm(betaPhiCohort[c],1)
        betaP[t,c] ~ dnorm(betaPCohort[c],1)
      }
    }
    
    # back-transform for examining output
    for (c in 1:nCohorts){
        betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
        betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
      for (t in 1:(T-1)){ 
        betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
        betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
      }
    }
    
    for (s in 1:nSeasons){
      for (c in 1:nCohorts){
        betaFlow[1,s,c] ~ dnorm(betaFlowCohort[1,c],1)
        betaFlow[2,s,c] ~ dnorm(betaFlowCohort[2,c],1)
      }   
    }
    
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):(last[i])){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last,
                       cohort = cohort, 
                       nCohorts = nCohorts,
                       season = seasonArray, #eh$seasons$season,
                       flow = eh$flow
                       )
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  zInitsNA <- ifelse(is.na(eh$flow), NA, 1)
  
  initialValues <- function() list(
    betaInt = rnorm(1, 0, 1),
    phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    p =   array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    z = zInitsNA,
    betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaP =   array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaPCohort =   array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaFlow = array(rnorm(2 * 4 * nCohorts, 0, 1), c(2, 4, nCohorts)),
    betaFlowCohort = array(rnorm(2 * nCohorts, 0, 1), c(2, nCohorts)),
    betaFlowTop = rnorm(2, 0, 1)
  )
  
  parametersToSave <- c("betaInt", 
                        "betaPhi", "betaP", "betaPhiCohort", "betaPCohort",
                        "betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut", 
                        "betaFlow",
                        "betaFlowCohort", "betaFlowTop")  
  nIter <- 20000 #30000
  nBurnin <- 10000 #15000
  nChains <- 2
  thinRate <- 5
  
  start = Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT_cohort_flowCohortHier, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort_flowCohortHier <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  
  elapsed_phiT_pT_cohort_flowCohortHier <- end - start
  toSave <- list(
    mcmc = mcmc.phiT_pT_cohort_flowCohortHier, 
    elapsed = elapsed_phiT_pT_cohort_flowCohortHier,
    name = "phiT_pT_cohort_flowCohortHier",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHier_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHier_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHier_mostRecent.RData')
}
# could consider forward algo to speed up convergence (https://oliviergimenez.github.io/banana-book/hmmcapturerecapture.html#nimble-implementation-1)

if(plotMCMCOutput) {

  #MCMCsummary(object = mcmc.phiT_pT_cohort_flowHier, round = 2)
  #MCMCplot(object = mcmc.phiT_pT_cohort_flowHier, params = "betaPhiOut")
  MCMCplot(object = toSave$mcmc, params = "betaFlowTop")
  MCMCplot(object = toSave$mcmc, params = "betaFlow")# 
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohort"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaFlowCohort"))
  
  priors <- rnorm(toSave$nIter * toSave$nChains, 0, 1/sqrt(.1))
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlowTop"),
            pdf = FALSE, 
            priors = priors)
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut"),
            pdf = FALSE, 
            priors = priors)
  
  priors <- rnorm(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlow"),
            pdf = FALSE, 
            priors = priors)
}

# run more iterations, if necessary
# nIterAdd <- 5000
# Cmcmc$run(nIterAdd, reset = FALSE)
# more_samples <- as.matrix(Cmcmc$mvSamples)
# 
# MCMCtrace(object = more_samples,
#           #ISB = FALSE,
#           #exact = TRUE, 
#           params = c("betaFlow"),
#           pdf = FALSE, 
#           priors = priors)

```

#### Get flow effect estimates
Flow effects vary across cohorts - hierarchical
```{r}
   #     betaInt +
   #     betaPhi[t,cohort[i]] + 
   #     betaFlow[1,season[t],cohort[i]] * flow[i,t] +
   #     betaFlow[2,season[t],cohort[i]] * flow[i,t] * flow[i,t]

load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHier_mostRecent.RData')
predFlowCohortHier <- getPredictionsFlowCohort(toSave, everyNIters = 2)

```

#### Plot predictions
```{r}
ggplot(predFlowCohortHier, aes(flow, predPhi, group = iter)) +
  geom_line(alpha = 0.025) +
  facet_grid(season ~ cohort)

# ggplot(predFlowCohortHier %>% filter(season ==1, cohort == 6), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.5) +
#   facet_grid(cohort ~ season)
# 
# ggplot(predFlowCohortHier %>% filter(cohort == 3), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap( ~ season)
# 
# ggplot(predFlowCohortHier %>% filter(season ==3), aes(flow, predPhi, group = iter)) +
  # geom_line(alpha = 0.1) +
  # facet_wrap(~ cohort)

```

#### BetaflowTop predictions
```{r}

getPredictionsFlowTop <- function(toSave, everyNIters = 10, flowStep = 0.5){

  mcmc <- toSave$mcmc
  
  ## betaFlow
  predictorsBetaFlowTop <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    var = 1:2,
     flow = seq(-1.5, 1.5, flowStep)
  )
  
  for(i in 1:nrow(predictorsBetaFlowTop)){
    predictorsBetaFlowTop$betaFlowTop1[i] <- mcmc$chain1[[predictorsBetaFlowTop[i, "iter"], 
                                                         1
                                                        ]]
    predictorsBetaFlowTop$betaFlowTop2[i] <- mcmc$chain1[[predictorsBetaFlowTop[i, "iter"], 
                                                         2
                                                        ]]
  }

  preds <- predictorsBetaFlowTop %>%
    mutate(predPhi = plogis(betaFlowTop1 * flow + betaFlowTop2 * flow * flow))
  
  return(preds)
}

predBetaFlowTop <- getPredictionsFlowTop(toSave, everyNIters = 10)

ggplot(predBetaFlowTop, aes(flow, predPhi, group = iter)) +
  geom_line() #+
  #facet_wrap(~iter)

ggplot(predBetaFlowTop, aes(betaFlowTop1, betaFlowTop2)) +
  geom_point()
```

### Model phiT_pT_cohort_flowCohortHierCJS
Flow effects vary by cohort, hierarchical across cohorts 
Same as previous model, but using nimble Ecology to run models  

#### Set up and run model
```{r phiT_pT_cohort_flowCohortHierCJS_River}
if (rerunSurivalModels) {
  
  y <- eh$eh
  (nCohorts <- nrow(unique(eh$cohorts)))
  (nSeasons <- nrow(unique(eh$seasons)))
  seasonArray <- c(3,4,1,2,3,4,1,2,3,4,1,2)
  
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  zInitsNA <- ifelse(is.na(eh$flow), NA, 1)
  
  myConstants <- list(N = nrow(y), 
                      T = ncol(y), 
                      first = first,
                      last = last,
                      cohort = cohort, 
                      nCohorts = nCohorts,
                      season = seasonArray, #eh$seasons$season,
                      flow = eh$flow,
                      ## DT changes:
                      ## this is used by both the dCJS and dDHMM distributions
                      length = last - first + 1
                      )
  
  ## DT changes:
  myData <- list(yCJS = y,    ## data for CJS distribution
                 y = y + 1)   ## data for DHMM distribution
  
  
  initialValues <- function() list(
                                  betaInt = rnorm(1, 0, 1),
                                  ## DT change:
                                  ## don't give phi and p initial values;
                                  ## they're deterministic nodes, so they'll be calculated
                                  ## in terms of other variables.  Also, when I made changes to these
                                  ## in the code, these (unnecessary) initial values were the wrong sizes
                                  ##phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
                                  ##p =   array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
                                  z = zInitsNA,
                                  betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
                                  betaP =   array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
                                  betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
                                  betaPCohort =   array(runif(nCohorts, 0, 1),c(nCohorts)),
                                  betaFlow = array(rnorm(2 * 4 * nCohorts, 0, 1), c(2, 4, nCohorts)),
                                  betaFlowCohort = array(rnorm(2 * nCohorts, 0, 1), c(2, nCohorts)),
                                  betaFlowTop = rnorm(2, 0, 1)
                              )
  
  
  ## if you change this FALSE to TRUE
  ## this makes the dataset smaller - only 200 observations,
  ## for quicker testing
  if(FALSE) {
      newN <- 200
      oldN <- dim(y)[1]
      set.seed(0)
      indToKeep <- sample(1:oldN, size = newN, replace = FALSE)
  }
  
  ## this removes the very last observation,
  ## since first[2376] = T = 12, which is not allowed
  ## to have the first observation occur on the final sampling period
  ## for either CJS or DHMM distributions
  if(TRUE) {
      indToKeep <- which(first < 12)
      newN <- length(indToKeep)
  }
  
  myConstants <- list(
      N = newN,
      T = myConstants$T,
      first = myConstants$first[indToKeep],
      last = myConstants$last[indToKeep],
      cohort = myConstants$cohort[indToKeep],
      nCohorts = myConstants$nCohorts,
      season = myConstants$season,
      flow = myConstants$flow[indToKeep,],
      length = myConstants$length[indToKeep]
  )
  
  myData <- list(
      yCJS = myData$yCJS[indToKeep,],
      y = myData$y[indToKeep,]
  )
  
  zInitsNA <- zInitsNA[indToKeep,]
  
  
  ## code using CJS distribution
  hmm.phiT_pT_cohort_flowCohortHierCJS <- nimbleCode({
      ## DT changes:
      ##delta[1] <- 1                    # Pr(alive t = 1) = 1
      ##delta[2] <- 0                    # Pr(dead t = 1) = 0
      ##
      for (i in 1:N){
          for (t in 1:(T-1)){ # loop over time
              logit(phi[t,i]) <- 
                  betaInt +
                  betaPhi[t,cohort[i]] + 
                  betaFlow[1,season[t],cohort[i]] * flow[i,t] +
                  betaFlow[2,season[t],cohort[i]] * flow[i,t] * flow[i,t]
          }
          ## DT changes:
          ## time t = first[i]:
          ## note this first value of p[] is not acually used by the dCJS distribution,
          ## but we include it for correctness
          p[first[i],i] <- 1
          ## time t > first[i]:
          for(t in (first[i]+1):last[i]) {
              ## DT changes:
              ## note the indexing on betaP:
              logit(p[t,i]) <- betaP[t-1,cohort[i]]             # prior detection
          }
      }
      ##    
      betaInt ~ dnorm(0,1)
      betaFlowTop[1] ~ dnorm(0,1)
      betaFlowTop[2] ~ dnorm(0,1)
      ##    
      for (c in 1:nCohorts){
          # mean values
          betaPhiCohort[c] ~ dnorm(0,1)
          betaPCohort[c] ~ dnorm(0,1)
          betaFlowCohort[1,c] ~ dnorm(betaFlowTop[1],1)
          betaFlowCohort[2,c] ~ dnorm(betaFlowTop[2],1)
          for (t in 1:(T-1)){ 
              betaPhi[t,c] ~ dnorm(betaPhiCohort[c],1)
              betaP[t,c] ~ dnorm(betaPCohort[c],1)
          }
      }
      ##    
      # back-transform for examining output
      for (c in 1:nCohorts){
          betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
          betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
          for (t in 1:(T-1)){ 
              betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
              betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
          }
      }
      ##    
      for (s in 1:nSeasons){
          for (c in 1:nCohorts){
              betaFlow[1,s,c] ~ dnorm(betaFlowCohort[1,c],1)
              betaFlow[2,s,c] ~ dnorm(betaFlowCohort[2,c],1)
          }   
      }
      ##    
      # likelihood
      for (i in 1:N){
          ## DT changes:
          ##z[i,first[i]] ~ dcat(delta[1:2])
          ##for (j in (first[i]+1):(last[i])){
          ##    z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
          ##    y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
          ##}
          yCJS[i,first[i]:last[i]] ~ dCJS_vv(probSurvive = phi[first[i]:last[i], i],
                                             probCapture = p[first[i]:last[i], i],
                                             len = length[i])
      }
  })
  
  set.seed(0)
  
  system.time(
      Rmodel <- nimbleModel(
          code = hmm.phiT_pT_cohort_flowCohortHierCJS,
          constants = myConstants,
          data = myData,              
          inits = initialValues(),
          calculate = FALSE
      )
  )
  
  Rmodel$calculate()
  ## latent state (200 ind): -2847.746
  ## dCJS_vv (200 individuals): -1199.098
  ## dCJS_vv (all but last observation): -1217.127
  
  
  parametersToSave <- c("betaInt", 
                        "betaPhi", "betaP", "betaPhiCohort", "betaPCohort",
                        "betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut", 
                        "betaFlow",
                        "betaFlowCohort", "betaFlowTop")  
  
  nIter <- 20000 #30000
  nBurnin <- 10000 #15000
  nChains <- 2
  thinRate <- 5
  
  start = Sys.time()
  
  system.time(
      conf <- configureMCMC(
          Rmodel,
          monitors = parametersToSave
      )
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort_flowCohortHierCJS <- runMCMC(
      Cmcmc, 
      niter = nIter, 
      nburnin = nBurnin, 
      thin = thinRate, 
      nchains = nChains
  )
  
  end <- Sys.time()
  
  elapsed_phiT_pT_cohort_flowCohortHierCJS <- end - start
  toSave <- list(
      mcmc = mcmc.phiT_pT_cohort_flowCohortHierCJS, 
      elapsed = elapsed_phiT_pT_cohort_flowCohortHierCJS,
      name = "phiT_pT_cohort_flowCohortHierCJS",
      myConstants = myConstants, 
      nIter = nIter, 
      nBurnin = nBurnin,
      thinRate = thinRate, 
      nSeasons = nSeasons, 
      nCohorts = nCohorts,
      nChains = nChains
  )
  
    save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHierCJS_', substr(end,1,13), '.RData'))
    save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHierCJS_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHierCJS_mostRecent.RData')
}

if(plotMCMCOutput) {

  #MCMCsummary(object = mcmc.phiT_pT_cohort_flowHier, round = 2)
  #MCMCplot(object = mcmc.phiT_pT_cohort_flowHier, params = "betaPhiOut")
  MCMCplot(object = toSave$mcmc, params = "betaFlowTop")
  MCMCplot(object = toSave$mcmc, params = "betaFlow")# 
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohort"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaFlowCohort"))
  
  priors <- rnorm(toSave$nIter * toSave$nChains, 0, 1/sqrt(.1))
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlowTop"),
            pdf = FALSE, 
            priors = priors)
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut"),
            pdf = FALSE, 
            priors = priors)
  
  priors <- rnorm(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlow"),
            pdf = FALSE, 
            priors = priors)
}

```

#### Get flow effect estimates
Flow effects vary across cohorts - hierarchical
```{r}
   #     betaInt +
   #     betaPhi[t,cohort[i]] + 
   #     betaFlow[1,season[t],cohort[i]] * flow[i,t] +
   #     betaFlow[2,season[t],cohort[i]] * flow[i,t] * flow[i,t]

load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHierCJS_mostRecent.RData')
predFlowCohortHierCJS <- getPredictionsFlowCohort(toSave, everyNIters = 2)

```

#### Plot predictions
```{r}
ggplot(predFlowCohortHierCJS, aes(flow, predPhi, group = iter)) +
  geom_line(alpha = 0.025) +
  facet_grid(season ~ cohort)

# ggplot(predFlowCohortHier %>% filter(season ==1, cohort == 6), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.5) +
#   facet_grid(cohort ~ season)
# 
# ggplot(predFlowCohortHier %>% filter(cohort == 3), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap( ~ season)
# 
# ggplot(predFlowCohortHier %>% filter(season ==3), aes(flow, predPhi, group = iter)) +
  # geom_line(alpha = 0.1) +
  # facet_wrap(~ cohort)

```

#### BetaflowTop predictions
```{r}

predBetaFlowTopCJS <- getPredictionsFlowTop(toSave, everyNIters = 10)

ggplot(predBetaFlowTopCJS, aes(flow, predPhi, group = iter)) +
  geom_line() #+
  #facet_wrap(~iter)

ggplot(predBetaFlowTopCJS, aes(betaFlowTop1, betaFlowTop2)) +
  geom_point()
```

### Model phiT_pT_cohort_flowCohortHierDHMM
Flow effects vary by cohort, hierarchical across cohorts 
Using nimble Ecology to run multistate models  

#### Set up and run model
```{r phiT_pT_cohort_flowCohortHierDHMM_River}
if (rerunSurivalModels) {
  
  y <- eh$eh
  (nCohorts <- nrow(unique(eh$cohorts)))
  (nSeasons <- nrow(unique(eh$seasons)))
  seasonArray <- c(3,4,1,2,3,4,1,2,3,4,1,2)
  
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  zInitsNA <- ifelse(is.na(eh$flow), NA, 1)
  
  myConstants <- list(N = nrow(y), 
                      T = ncol(y), 
                      first = first,
                      last = last,
                      cohort = cohort, 
                      nCohorts = nCohorts,
                      season = seasonArray, #eh$seasons$season,
                      flow = eh$flow,
                      ## DT changes:
                      ## this is used by both the dCJS and dDHMM distributions
                      length = last - first + 1
                      )
  
  ## DT changes:
  myData <- list(yCJS = y,    ## data for CJS distribution
                 y = y + 1)   ## data for DHMM distribution
  
  
  initialValues <- function() list(
                                  betaInt = rnorm(1, 0, 1),
                                  ## DT change:
                                  ## don't give phi and p initial values;
                                  ## they're deterministic nodes, so they'll be calculated
                                  ## in terms of other variables.  Also, when I made changes to these
                                  ## in the code, these (unnecessary) initial values were the wrong sizes
                                  ##phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
                                  ##p =   array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
                                  z = zInitsNA,
                                  betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
                                  betaP =   array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
                                  betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
                                  betaPCohort =   array(runif(nCohorts, 0, 1),c(nCohorts)),
                                  betaFlow = array(rnorm(2 * 4 * nCohorts, 0, 1), c(2, 4, nCohorts)),
                                  betaFlowCohort = array(rnorm(2 * nCohorts, 0, 1), c(2, nCohorts)),
                                  betaFlowTop = rnorm(2, 0, 1)
                              )
  
  
  ## if you change this FALSE to TRUE
  ## this makes the dataset smaller - only 200 observations,
  ## for quicker testing
  if(FALSE) {
      newN <- 200
      oldN <- dim(y)[1]
      set.seed(0)
      indToKeep <- sample(1:oldN, size = newN, replace = FALSE)
  }
  
  ## this removes the very last observation,
  ## since first[2376] = T = 12, which is not allowed
  ## to have the first observation occur on the final sampling period
  ## for either CJS or DHMM distributions
  if(TRUE) {
      indToKeep <- which(first < 12)
      newN <- length(indToKeep)
  }
  
  myConstants <- list(
      N = newN,
      T = myConstants$T,
      first = myConstants$first[indToKeep],
      last = myConstants$last[indToKeep],
      cohort = myConstants$cohort[indToKeep],
      nCohorts = myConstants$nCohorts,
      season = myConstants$season,
      flow = myConstants$flow[indToKeep,],
      length = myConstants$length[indToKeep]
  )
  
  myData <- list(
      yCJS = myData$yCJS[indToKeep,],
      y = myData$y[indToKeep,]
  )
  
  zInitsNA <- zInitsNA[indToKeep,]
  
  ## model code using DHMMo distribution
  hmm.phiT_pT_cohort_flowCohortHierDHMM <- nimbleCode({
      delta[1] <- 1                    # Pr(alive t = 1) = 1
      delta[2] <- 0                    # Pr(dead t = 1) = 0
      ##
      for (i in 1:N){
          for (t in 1:(T-1)){ # loop over time
              logit(phi[t,i]) <- 
                  betaInt +
                  betaPhi[t,cohort[i]] + 
                  betaFlow[1,season[t],cohort[i]] * flow[i,t] +
                  betaFlow[2,season[t],cohort[i]] * flow[i,t] * flow[i,t]
              # prior survival
              ##
              gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
              gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
              gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
              gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
              ##            
              ## DT changes:
              ## definition of omega is moved below, to make it
              ## correctly condition on the first (positive) observation
              ##logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
              ##omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
              ##omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
              ##omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
              ##omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
          }
          ## DT changes:
          ## need to pad the gamma matrix with an extra t=T row, to ensure it's
          ## always a matrix.  This values are never actually used (except maybe for internal checking of row sums = 1),
          ## but defining them is necessary.
          gamma[1,1,T,i] <- 0
          gamma[1,2,T,i] <- 1
          gamma[2,1,T,i] <- 0
          gamma[2,2,T,i] <- 1
          ## DT changes:
          ## time period t = first[i]: guaranteed detection:
          omega[1,1,first[i],i] <- 0       # Pr(alive t -> non-detected t)
          omega[1,2,first[i],i] <- 1           # Pr(alive t -> detected t)
          omega[2,1,first[i],i] <- 1              # Pr(dead t -> non-detected t)
          omega[2,2,first[i],i] <- 0              # Pr(dead t -> detected t)
          ## DT changes:
          ## time t > first[i]:
          for(t in (first[i]+1):last[i]) {
              logit(p[t,i]) <- betaP[t-1,cohort[i]]             # prior detection
              omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
              omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
              omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
              omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
          }
      }
      ##    
      betaInt ~ dnorm(0,1)
      betaFlowTop[1] ~ dnorm(0,1)
      betaFlowTop[2] ~ dnorm(0,1)
      ##    
      for (c in 1:nCohorts){
          # mean values
          betaPhiCohort[c] ~ dnorm(0,1)
          betaPCohort[c] ~ dnorm(0,1)
          betaFlowCohort[1,c] ~ dnorm(betaFlowTop[1],1)
          betaFlowCohort[2,c] ~ dnorm(betaFlowTop[2],1)
          for (t in 1:(T-1)){ 
              betaPhi[t,c] ~ dnorm(betaPhiCohort[c],1)
              betaP[t,c] ~ dnorm(betaPCohort[c],1)
          }
      }
      ##    
      # back-transform for examining output
      for (c in 1:nCohorts){
          betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
          betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
          for (t in 1:(T-1)){ 
              betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
              betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
          }
      }
      ##    
      for (s in 1:nSeasons){
          for (c in 1:nCohorts){
              betaFlow[1,s,c] ~ dnorm(betaFlowCohort[1,c],1)
              betaFlow[2,s,c] ~ dnorm(betaFlowCohort[2,c],1)
          }   
      }
      ##    
      # likelihood
      for (i in 1:N){
          ## DT changes:
          ##z[i,first[i]] ~ dcat(delta[1:2])
          ##for (j in (first[i]+1):(last[i])){
          ##    z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
          ##    y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
          ##}
          y[i,first[i]:last[i]] ~ dDHMMo(init = delta[1:2],
                                         probTrans = gamma[1:2, 1:2, first[i]:last[i], i],
                                         probObs = omega[1:2, 1:2, first[i]:last[i], i],
                                         len = length[i],
                                         checkRowSums = 1)
      }
  })
  
  set.seed(0)

  ## you'll get warnings that the data 'yCJS' is not used, and the 'z' initial
  ## values are not in the model.  Those don't cause any problems,
  ## and let us use the same myData and initialValue() for both models.
  system.time(
      Rmodel <- nimbleModel(
          code = hmm.phiT_pT_cohort_flowCohortHierDHMM,
          constants = myConstants,
          data = myData,              
          inits = initialValues(),
          calculate = FALSE
      )
  )
  
  Rmodel$calculate()
  ## latent state: -29141.62
  ## latent state (200 ind): -2847.746
  ## dDHMMo (200 ind): -1199.098 (same as CJS)
  ## dDHMMo (all but last observation): -1217.127 (same as CJS)
  
  parametersToSave <- c("betaInt", 
                        "betaPhi", "betaP", "betaPhiCohort", "betaPCohort",
                        "betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut", 
                        "betaFlow",
                        "betaFlowCohort", "betaFlowTop")  
  
  nIter <- 20000 #30000
  nBurnin <- 10000 #15000
  nChains <- 2
  thinRate <- 5
  
  start = Sys.time()
  
  system.time(
      conf <- configureMCMC(
          Rmodel,
          monitors = parametersToSave
      )
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort_flowCohortHierDHMM <- runMCMC(
      Cmcmc, 
      niter = nIter, 
      nburnin = nBurnin, 
      thin = thinRate, 
      nchains = nChains
  )
  
  end <- Sys.time()
  elapsed_phiT_pT_cohort_flowCohortHierDHMM <- end - start
  toSave <- list(
      mcmc = mcmc.phiT_pT_cohort_flowCohortHierDHMM, 
      elapsed = elapsed_phiT_pT_cohort_flowCohortHierDHMM,
      name = "phiT_pT_cohort_flowCohortHierDHMM",
      myConstants = myConstants, 
      nIter = nIter, 
      nBurnin = nBurnin,
      thinRate = thinRate, 
      nSeasons = nSeasons, 
      nCohorts = nCohorts,
      nChains = nChains
  )
  
    save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHierDHMM_', substr(end,1,13), '.RData'))
    save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHierDHMM_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHierDHMM_mostRecent.RData')
}

if(plotMCMCOutput) {

  #MCMCsummary(object = mcmc.phiT_pT_cohort_flowHier, round = 2)
  #MCMCplot(object = mcmc.phiT_pT_cohort_flowHier, params = "betaPhiOut")
  MCMCplot(object = toSave$mcmc, params = "betaFlowTop")
  MCMCplot(object = toSave$mcmc, params = "betaFlow")# 
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohort"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaFlowCohort"))
  
  priors <- rnorm(toSave$nIter * toSave$nChains, 0, 1/sqrt(.1))
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlowTop"),
            pdf = FALSE, 
            priors = priors)
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut"),
            pdf = FALSE, 
            priors = priors)
  
  priors <- rnorm(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlow"),
            pdf = FALSE, 
            priors = priors)
}

```

#### Get flow effect estimates
Flow effects vary across cohorts - hierarchical
```{r}
   #     betaInt +
   #     betaPhi[t,cohort[i]] + 
   #     betaFlow[1,season[t],cohort[i]] * flow[i,t] +
   #     betaFlow[2,season[t],cohort[i]] * flow[i,t] * flow[i,t]

load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHierDHMM_mostRecent.RData')
predFlowCohortHierDHMM <- getPredictionsFlowCohort(toSave, everyNIters = 2)

```

#### Plot predictions
```{r}
ggplot(predFlowCohortHierDHMM, aes(flow, predPhi, group = iter)) +
  geom_line(alpha = 0.025) +
  facet_grid(season ~ cohort)

# ggplot(predFlowCohortHier %>% filter(season ==1, cohort == 6), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.5) +
#   facet_grid(cohort ~ season)
# 
# ggplot(predFlowCohortHier %>% filter(cohort == 3), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap( ~ season)
# 
# ggplot(predFlowCohortHier %>% filter(season ==3), aes(flow, predPhi, group = iter)) +
  # geom_line(alpha = 0.1) +
  # facet_wrap(~ cohort)

```

#### BetaflowTop predictions
```{r}

predBetaFlowTopDHMM <- getPredictionsFlowTop(toSave, everyNIters = 10)

ggplot(predBetaFlowTopDHMM, aes(flow, predPhi, group = iter)) +
  geom_line() #+
  #facet_wrap(~iter)

ggplot(predBetaFlowTopDHMM, aes(betaFlowTop1, betaFlowTop2)) +
  geom_point()
```



### Compare models
```{r compare models_River}

#data.frame(model = c("(phi,p)",
#                     "(phit,pt)"),
#           WAIC = c(mcmc.phi_p, 
#                    mcmc.phiT_pT))


```


<!-- ### Model phiT_pT_isYOY -->
<!-- Add structure for isYOY. This was important for the integrated growth/survival model, but probably not relevant here since we are estimating phi and p for each ageInSamples -->
<!-- ```{r phiT_pT_cohortisYOY} -->

<!-- # Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html -->
<!-- if (rerunSurivalModels) { -->

<!--   y <- eh$eh -->
<!--   nSeasons <- nrow(unique(eh$seasons)) -->
<!--   nCohorts <- nrow(unique(eh$cohorts)) -->

<!--   hmm.phiT_pT_isYOY <- nimbleCode({ -->
<!--     delta[1] <- 1                    # Pr(alive t = 1) = 1 -->
<!--     delta[2] <- 0                    # Pr(dead t = 1) = 0 -->

<!--     for (i in 1:N){ -->
<!--       for (t in 1:(T-1)){ # loop over time -->
<!--         #logit(phi[t,i]) <- betaPhi[t,isYOY[i,t]]           # prior survival -->
<!--         logit(phi[t,i]) <- betaPhi[t]    # prior survival -->
<!--         gamma[1,1,t,i] <- phi[t,i]       # Pr(alive t -> alive t+1) -->
<!--         gamma[1,2,t,i] <- 1 - phi[t,i]   # Pr(alive t -> dead t+1) -->
<!--         gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1) -->
<!--         gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1) -->

<!--         logit(p[t,i]) <- betaP[t]        # prior detection -->
<!--         omega[1,1,t,i] <- 1 - p[t,i]     # Pr(alive t -> non-detected t) -->
<!--         omega[1,2,t,i] <- p[t,i]         # Pr(alive t -> detected t) -->
<!--         omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t) -->
<!--         omega[2,2,t,i] <- 0              # Pr(dead t -> detected t) -->
<!--       } -->
<!--     } -->

<!--     for (y in 1:2){ -->
<!--       # mean values -->
<!--       betaPhiIsYOY[y] ~ dnorm(0,1) -->
<!--       betaPIsYOY[y] ~ dnorm(0,1) -->
<!--     } -->

<!--     # isYOY = 1 -->
<!--     for (t in 1:3){  -->
<!--       betaPhi[t] ~ dnorm(betaPhiIsYOY[1], 1) -->
<!--       betaP[t] ~ dnorm(betaPIsYOY[1], 1) -->
<!--     } -->
<!--     # isYOY = 2, older fish -->
<!--     for (t in 4:(T-1)){  -->
<!--       betaPhi[t] ~ dnorm(betaPhiIsYOY[2], 1) -->
<!--       betaP[t] ~ dnorm(betaPIsYOY[2], 1) -->
<!--     } -->

<!--     # Backtransform for output -->
<!--     for (y in 1:2){ -->
<!--         betaPhiIsYOYOut[y] <- 1/(1 + exp(-betaPhiIsYOY[y])) -->
<!--         betaPIsYOYOut[y] <- 1/(1 + exp(-betaPIsYOY[y])) -->
<!--     } -->
<!--     for (t in 1:(T-1)){  -->
<!--       betaPhiOut[t] <- 1/(1 + exp(-betaPhi[t])) -->
<!--       betaPOut[t] <- 1/(1 + exp(-betaP[t]))  -->
<!--     } -->


<!--     # likelihood -->
<!--     for (i in 1:N){ -->
<!--       z[i,first[i]] ~ dcat(delta[1:2]) -->
<!--       for (j in (first[i]+1):last[i]){ -->
<!--         z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i]) -->
<!--         y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i]) -->
<!--       } -->
<!--     } -->
<!--   }) -->

<!--   first <- eh$first #apply(y, 1, function(x) min(which(x !=0))) -->
<!--   last <- eh$last -->

<!--   myConstants <- list(N = nrow(y), -->
<!--                       T = ncol(y), -->
<!--                       first = first, -->
<!--                       last = last, -->
<!--                       isYOY = eh$isYOY -->
<!--                       ) -->

<!--   myData <- list(y = y + 1) -->

<!--   zinits <- y + 1 # non-detection -> alive -->
<!--   zinits[zinits == 2] <- 1 # dead -> alive -->
<!--   zInitsNA <- ifelse(is.na(eh$isYOY), NA, 1) -->

<!--   initialValues <- function() list( -->
<!--     phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)), -->
<!--     p =   array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)), -->
<!--     z = zInitsNA, -->
<!--     betaPhi = array(runif((myConstants$T - 1), 0, 1),c((myConstants$T - 1))), -->
<!--     betaP = array(runif((myConstants$T - 1), 0, 1),c((myConstants$T - 1))), -->
<!--     betaPhiIsYOY = array(runif(2, 0, 1),c(2)), -->
<!--     betaPIsYOY = array(runif(2, 0, 1),c(2)) -->
<!--   ) -->

<!--   parametersToSave <- c("betaPhiOut", "betaPOut", "betaPIsYOYOut", "betaPhiIsYOYOut") -->
<!--   nIter <- 5000 -->
<!--   nBurnin <- 1000 -->
<!--   nChains <- 2 -->
<!--   thinRate <- 5 -->

<!--   start <- Sys.time() -->
<!--   Rmodel <- nimbleModel( -->
<!--     code = hmm.phiT_pT_isYOY, -->
<!--     constants = myConstants, -->
<!--     data = myData, -->
<!--     inits = initialValues(), -->
<!--     calculate = FALSE -->
<!--   ) -->
<!--   conf <- configureMCMC( -->
<!--     Rmodel, -->
<!--     monitors = parametersToSave -->
<!--   ) -->

<!--   Rmcmc <- buildMCMC(conf, useConjugacy = FALSE) -->
<!--   Cmodel <- compileNimble(Rmodel) -->
<!--   Cmcmc <- compileNimble(Rmcmc, project = Rmodel) -->

<!--   mcmc.phiT_pT_isYOY <- runMCMC( -->
<!--     Cmcmc, -->
<!--     niter = nIter, -->
<!--     nburnin = nBurnin, -->
<!--     thin = thinRate, -->
<!--     nchains = nChains -->
<!--   ) -->

<!--   end <- Sys.time() -->
<!--   elapsed_phiT_pT_isYOY <- end - start -->

<!--     toSave <- list( -->
<!--       mcmc = mcmc.phiT_pT_isYOY, -->
<!--       elapsed = elapsed_phiT_pT_isYOY, -->
<!--       myConstants = myConstants, -->
<!--       nIter = nIter, -->
<!--       nBurnin = nBurnin, -->
<!--       thinRate = thinRate, -->
<!--       nSeasons = nSeasons, -->
<!--       nCohorts = nCohorts, -->
<!--       nChains = nChains -->
<!--     ) -->
<!--   save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_isYOY_', substr(end,1,13), '.RData')) -->
<!--   save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_isYOY_mostRecent.RData') -->
<!-- } else { -->
<!--   load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_isYOY_mostRecent.RData') -->
<!-- } -->

<!-- if(plotMCMCOutput) { -->
<!--   MCMCsummary(object = toSave$mcmc, round = 2) -->

<!--   MCMCplot(object = toSave$mcmc, params = "betaPhiIsYOYOut") -->
<!--   MCMCplot(object = toSave$mcmc, params = "betaPhiOut") -->
<!--   MCMCplot(object = toSave$mcmc, params = "betaPOut")# -->

<!--   priors <-  runif(toSave$nIter * toSave$nChains, 0, 1) -->
<!--   MCMCtrace(object = toSave$mcmc, -->
<!--             #ISB = FALSE, -->
<!--             #exact = TRUE, -->
<!--             params = c("betaPhiOut"), -->
<!--             pdf = FALSE, -->
<!--             priors = priors) -->

<!-- } -->

<!-- ``` -->
