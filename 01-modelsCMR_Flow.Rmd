## Flow effects on survival (phi) models {#modelCMR_Flow}

```{r globalModelsNimble, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE)
```


```{r librariesModelsNimble, echo = FALSE}
library(getWBData)
library(lubridate)
library(kableExtra)
library(GGally)
library(nimble)
library(MCMCvis)
library(tidyverse)
```

```{r}
rerunSurivalModels <- TRUE
plotMCMCOutput <- TRUE
```


### Read in encounter history (eh) data
```{r}
load('./models/cmrFlowWB/dataOut/eh_2002200320042005200620072008200920102011201220132014_wb obear.RData')
```

### run model phi_p 
#### Single estimates of phi and p (across, time, cohorts, flow)
```{r phi_p, cache=TRUE}
# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html

if (rerunSurivalModels) {
  y <- eh$eh
  
  nSeasons <- nrow(unique(eh$seasons))
  nCohorts <- nrow(unique(eh$cohorts))
  
  hmm.phi_p <- nimbleCode({
    phi ~ dunif(0, 1) # prior survival
    p ~ dunif(0, 1) # prior detection
    # likelihood
    gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
    gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
    gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
    gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
    delta[1] <- 1          # Pr(alive t = 1) = 1
    delta[2] <- 0          # Pr(dead t = 1) = 0
    omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
    omega[1,2] <- p        # Pr(alive t -> detected t)
    omega[2,1] <- 1        # Pr(dead t -> non-detected t)
    omega[2,2] <- 0        # Pr(dead t -> detected t)
    
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):last[i]){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
        y[i,j] ~ dcat(omega[z[i,j], 1:2])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last)
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  initialValues <- function() list(phi = runif(1,0,1),
                                    p = runif(1,0,1),
                                    z = zinits
                                    )
  
  
  parametersToSave <- c("phi", "p")  
  nIter <- 5000
  nBurnin <- 1000
  nChains <- 2
  thinRate = 5
  
  start <- Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phi_p, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phi_p <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  elapsed_phi_p <- end - start
  toSave <- list(
    mcmc = mcmc.phi_p, 
    elapsed = elapsed_phi_p,
    name = "phi_p",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phi_p_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phi_p_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phi_p_mostRecent.RData')
}

if(plotMCMCOutput) {
  #MCMCsummary(object = mcmc.phi_p, round = 2)
  MCMCplot(object = toSave$mcmc)
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            ISB = FALSE,
            exact = TRUE, 
            params = c("phi", "p"),
            pdf = FALSE, 
            priors = priors)
}
```


### run model phi_p, with isYOY 
### not working as of 5/12/22 - initialization problems
```{r phiT_pT_cohortisYOY, cache=TRUE}
# 
# # Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
# if (rerunSurivalModels) {
# 
#   y <- eh$eh
#   
#   hmm.phiT_pT_isYOY <- nimbleCode({
#     delta[1] <- 1                    # Pr(alive t = 1) = 1
#     delta[2] <- 0                    # Pr(dead t = 1) = 0
#     
#     for (i in 1:N){
#       for (t in 1:(T-1)){ # loop over time
#         logit(phi[t,i]) <- betaPhi[isYOY[i,t]]           # prior survival
#         gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
#         gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
#         gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
#         gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
#         
#         logit(p[t,i]) <- betaP[isYOY[i,t]]             # prior detection
#         omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
#         omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
#         omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
#         omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
#       }
#     }
#     
#     
#     for (c in 1:2){
#       # mean values
#      # betaPhiIsYOY[c] ~ dnorm(0,1)
#     #  betaPIsYOY[c] ~ dnorm(0,1)
#      # for (t in 1:(T-1)){ 
#         betaPhi[c] ~ dnorm(0, 1)
#         betaP[c] ~ dnorm(0, 1)
#       #}
#     }
#     
#     # back-transform for examining output
#     for (c in 1:2){
#      #   betaPhiIsYOYOut[c] <- 1/(1 + exp(-betaPhiIsYOY[c]))
#     #    betaPIsYOYOut[c] <- 1/(1 + exp(-betaPIsYOY[c]))
#      # for (t in 1:(T-1)){ 
#         betaPhiOut[c] <- 1/(1 + exp(-betaPhi[c]))
#         betaPOut[c] <- 1/(1 + exp(-betaP[c])) 
#     #  }
#     }
#     
#     # likelihood
#     for (i in 1:N){
#       z[i,first[i]] ~ dcat(delta[1:2])
#       for (j in (first[i]+1):last[i]){
#         z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
#         y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
#       }
#     }
#   })
#     
#   first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
#   last <- eh$last
#   
#   myConstants <- list(N = nrow(y), 
#                        T = ncol(y), 
#                        first = first,
#                        last = last,
#                        isYOY = eh$isYOY
#                        )
#   
#   myData <- list(y = y + 1)
#   
#   zinits <- y + 1 # non-detection -> alive
#   zinits[zinits == 2] <- 1 # dead -> alive
#   
#   initialValues <- function() list(
#     phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
#     p = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
#     z = zinits,
#     betaPhi = array(runif(2, 0, 1),c(2)),
#     betaP = array(runif(2, 0, 1),c(2))
#   )
#   
#   parametersToSave <- c("betaPhiOut", "betaPOut", "betaPhiisYOYOut", "betaPisYOYOut")  
#   nIter <- 5000
#   nBurnin <- 1000
#   nChains <- 2
#   
#   start <- Sys.time()
#   Rmodel <- nimbleModel(
#     code = hmm.phiT_pT_isYOY, 
#     constants = myConstants,
#     data = myData,              
#     inits = initialValues(),
#     calculate = FALSE
#   )
#   conf <- configureMCMC(
#     Rmodel,
#     monitors = parametersToSave
#   )
#   
#   Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
#   Cmodel <- compileNimble(Rmodel)
#   Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
#   
#   mcmc.phiT_pT_isYOY <- runMCMC(
#     Cmcmc, 
#     niter = nIter, 
#     nburnin = nBurnin, 
#     thin = thinRate, 
#     nchains = nChains
#   )
#   
#   end <- Sys.time()
#   elapsed_phiT_pT_isYOY <- end - start
#   
#     toSave <- list(
#       mcmc = mcmc.phiT_pT_isYOY, 
#       elapsed = elapsed_phiT_pT_isYOY, 
#       myConstants = myConstants, 
#       nIter = nIter, 
#       nBurnin = nBurnin,
#       thinRate = thinRate, 
#       nSeasons = nSeasons, 
#       nCohorts = nCohorts
#     )
#   save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_isYOY_', substr(end,1,13), '.RData'))
#   save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_isYOY_mostRecent.RData')
# } else {
#   load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_isYOY_mostRecent.RData')
# }
#   
# if(plotMCMCOutput) {  
#   MCMCsummary(object = mcmc.phiT_pT_isYOY, round = 2)
#   #MCMCplot(object = mcmc.phiT_pT_isYOY, params = "betaPhiOut")
#   #MCMCplot(object = mcmc.phiT_pT_isYOY, params = "betaPOut")# 
#   MCMCplot(object = mcmc.phiT_pT_isYOY, params = c("betaPhiisYOYOut"))
#   MCMCplot(object = mcmc.phiT_pT_isYOY, params = c("betaPisYOYOut"))
#   
#   priors <- runif(nIter * nChains, 0, 1)
#   MCMCtrace(object = mcmc.phiT_pT_isYOY,
#             #ISB = FALSE,
#             #exact = TRUE, 
#             params = c("betaPhiisYOYOut"),
#             pdf = FALSE, 
#             priors = priors)
# }

```


### run model phiT_pT
#### Phi and p vary by sampling occasion (time)
```{r phiT_pT, cache=TRUE}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nSeasons <- nrow(unique(eh$seasons))
  nCohorts <- nrow(unique(eh$cohorts))
  
  hmm.phiT_pT <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    for (t in 1:(T-1)){ # loop over time
      phi[t] ~ dunif(0, 1)           # prior survival
      gamma[1,1,t] <- phi[t]         # Pr(alive t -> alive t+1)
      gamma[1,2,t] <- 1 - phi[t]     # Pr(alive t -> dead t+1)
      gamma[2,1,t] <- 0              # Pr(dead t -> alive t+1)
      gamma[2,2,t] <- 1              # Pr(dead t -> dead t+1)
      p[t] ~ dunif(0, 1)             # prior detection
      omega[1,1,t] <- 1 - p[t]       # Pr(alive t -> non-detected t)
      omega[1,2,t] <- p[t]           # Pr(alive t -> detected t)
      omega[2,1,t] <- 1              # Pr(dead t -> non-detected t)
      omega[2,2,t] <- 0              # Pr(dead t -> detected t)
    }
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):last[i]){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last)
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  initialValues <- function() list(phi = runif(myConstants$T - 1, 0, 1),
                                    p = runif(myConstants$T - 1, 0, 1),
                                    z = zinits)
  
  parametersToSave <- c("phi", "p")  
  nIter <- 5000
  nBurnin <- 1000
  nChains <- 2
  thinRate <- 5
  
  start <- Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  
  
  end <- Sys.time()
  elapsed_phiT_pT <- end - start
    toSave <- list(
      mcmc = mcmc.phiT_pT, 
      elapsed = elapsed_phiT_pT,
      name = "phiT_pT",
      myConstants = myConstants, 
      nIter = nIter, 
      nBurnin = nBurnin,
      thinRate = thinRate, 
      nSeasons = nSeasons, 
      nCohorts = nCohorts,
      nChains = nChains
    )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_mostRecent.RData')
}
  
if (plotMCMCOutput) {  
  #MCMCsummary(object = mcmc.phiT_pT, round = 2)
  MCMCplot(object = toSave$mcmc)
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            #params = c("phi[1]", "phi[2]", "phi[3]", "phi[4]", "phi[5]", "phi[9]", "phi[10]",
            #           "p[1]", "p[2]", "p[3]", "p[4]", "p[5]"),
            params = c("phi"),
            pdf = FALSE, 
            priors = priors)
}

```

### run model phiT_pT_cohort
#### Phi and p vary by time and there is a cohort effect on phi
```{r phiT_pT_cohort, cache=TRUE}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nCohorts <- nrow(unique(eh$cohorts))
  
  hmm.phiT_pT_cohort <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    
    for (i in 1:N){
      for (t in 1:(T-1)){ # loop over time
        logit(phi[t,i]) <- betaPhi[t,cohort[i]]           # prior survival
        gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
        gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
        gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
        gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
        
        logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
        omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
        omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
        omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
        omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
      }
    }
    
    
    for (c in 1:nCohorts){
      # mean values
      betaPhiCohort[c] ~ dnorm(0,1)
      betaPCohort[c] ~ dnorm(0,1)
      for (t in 1:(T-1)){ 
        betaPhi[t,c] ~ dnorm(betaPhiCohort[c], 1)
        betaP[t,c] ~ dnorm(betaPCohort[c], 1)
      }
    }
    
    # back-transform for examining output
    for (c in 1:nCohorts){
        betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
        betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
      for (t in 1:(T-1)){ 
        betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
        betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
      }
    }
    
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):last[i]){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last,
                       cohort = cohort, 
                       nCohorts = nCohorts
                       )
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  initialValues <- function() list(
    phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    p = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    z = zinits,
    betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaP = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaPCohort = array(runif(nCohorts, 0, 1),c(nCohorts))
  )
  
  parametersToSave <- c("betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut")  
  nIter <- 5000
  nBurnin <- 1000
  nChains <- 2
  thinRate = 5
  
  start <- Sys.time()
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT_cohort, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  elapsed_phiT_pT_cohort <- end - start
    toSave <- list(
      mcmc = mcmc.phiT_pT_cohort, 
      elapsed = elapsed_phiT_pT_cohort,
      name = "phiT_pT_cohort",
      myConstants = myConstants, 
      nIter = nIter, 
      nBurnin = nBurnin,
      thinRate = thinRate, 
      nSeasons = nSeasons, 
      nCohorts = nCohorts,
      nChains = nChains
    )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_mostRecent.RData')
}
  
if(plotMCMCOutput) {  
  #MCMCsummary(object = toSave$mcmc, round = 2)
  #MCMCplot(object = mcmc.phiT_pT_cohort, params = "betaPhiOut")
  #MCMCplot(object = mcmc.phiT_pT_cohort, params = "betaPOut")# 
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut"),
            pdf = FALSE, 
            priors = priors)
}

```

### run model phiT_pT_cohort_flow
#### Add mean flow over the interval as a survival effect
```{r phiT_pT_cohort_flow, cache=TRUE}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nCohorts <- nrow(unique(eh$cohorts))
  nSeasons <- nrow(unique(eh$seasons))
  
  hmm.phiT_pT_cohort_flow <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    
    for (i in 1:N){
      for (t in 1:(T-1)){ # loop over time
        logit(phi[t,i]) <- 
          betaInt +
          betaPhi[t,cohort[i]] + 
          betaFlow[1,season[i]] * flow[i,t] +
          betaFlow[2,season[i]] * flow[i,t] * flow[i,t]
           # prior survival
        
        gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
        gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
        gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
        gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
        
        logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
        omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
        omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
        omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
        omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
      }
    }
    
    betaInt ~ dnorm(0,1)
    
    for (c in 1:nCohorts){
      # mean values
      betaPhiCohort[c] ~ dnorm(0,1)
      betaPCohort[c] ~ dnorm(0,1)
      for (t in 1:(T-1)){ 
        betaPhi[t,c] ~ dnorm(betaPhiCohort[c], 1)
        betaP[t,c] ~ dnorm(betaPCohort[c], 1)
      }
    }
    
    # back-transform for examining output
    for (c in 1:nCohorts){
        betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
        betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
      for (t in 1:(T-1)){ 
        betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
        betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
      }
    }
    
    for (s in 1:nSeasons){
      betaFlow[1,s] ~ dnorm(0, 1)
      betaFlow[2,s] ~ dnorm(0, 1)
    }    
    
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):(last[i])){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last,
                       cohort = cohort, 
                       nCohorts = nCohorts,
                       season = eh$seasons$season,
                       flow = eh$flow
                       )
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  zInitsNA <- ifelse(is.na(eh$flow), NA, 1)
  
  initialValues <- function() list(
    betaInt = rnorm(1, 0, 1),
    phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    p =   array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    z = zInitsNA,
    betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaP =   array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaPCohort =   array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaFlow = array(rnorm(2 * 4, 0, 1), c(2, 4))
  )
  
  parametersToSave <- c("betaInt", 
                        "betaPhi", "betaP", "betaPhiCohort", "betaPCohort",
                        "betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut", 
                        "betaFlow")  
  nIter <- 20000
  nBurnin <- 10000
  nChains <- 2
  thinRate <- 5
  
  start = Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT_cohort_flow, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort_flow <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  
  elapsed_phiT_pT_cohort_flow <- end - start
  toSave <- list(
    mcmc = mcmc.phiT_pT_cohort_flow, 
    elapsed = elapsed_phiT_pT_cohort_flow,
    name = "phiT_pT_cohort_flow",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flow_', substr(end,1,13), '.RData'))
    save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flow_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flow_mostRecent.RData')
}
# could consider forward algo to speed up convergence (https://oliviergimenez.github.io/banana-book/hmmcapturerecapture.html#nimble-implementation-1)

if(plotMCMCOutput) {
  #MCMCsummary(object = toSave$mcmc, round = 2)
  #MCMCplot(object = mcmc.phiT_pT_cohort_flow, params = "betaPhiOut")
  MCMCplot(object = toSave$mcmc, params = "betaFlow")# 
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut"),
            pdf = FALSE, 
            priors = priors)
  
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlow"),
            pdf = FALSE, 
            priors = priors)
}
# run more iterations, if necessary
# nIterAdd <- 5000
# Cmcmc$run(nIterAdd, reset = FALSE)
# more_samples <- as.matrix(Cmcmc$mvSamples)
# 
# MCMCtrace(object = more_samples,
#           #ISB = FALSE,
#           #exact = TRUE, 
#           params = c("betaFlow"),
#           pdf = FALSE, 
#           priors = priors)

```

### Get flow effect estimates
#### Flow effects fixed across cohorts
```{r}
   #     betaInt +
   #     betaPhi[t,cohort[i]] + 
   #     betaFlow[1,season[i]] * flow[i,t] +
   #     betaFlow[2,season[i]] * flow[i,t] * flow[i,t]


getPredictionsFlow <- function(mcmc, everyNIters = 10, flowStep = 0.5){

  ## betaInt
  predictorsBetaInt <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters)
  )
  for(i in 1:nrow(predictorsBetaInt)){
    predictorsBetaInt$betaInt[i] <- mcmc$chain1[[ predictorsBetaInt[i, "iter"], "betaInt" ]]
  }
  
  
  ## betaFlow
  predictorsBetaFlow <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    season = 1:toSave$nSeasons
  )
  
  for(i in 1:nrow(predictorsBetaFlow)){
    predictorsBetaFlow$betaFlow1[i] <- mcmc$chain1[[predictorsBetaFlow[i, "iter"], 
                                                   paste0("betaFlow[1, ", predictorsBetaFlow[i, "season"],
                                                          "]")
                                                  ]]
    predictorsBetaFlow$betaFlow2[i] <- mcmc$chain1[[predictorsBetaFlow[i, "iter"], 
                                                   paste0("betaFlow[2, ", predictorsBetaFlow[i, "season"],
                                                          "]")
                                                  ]]
  }
  
  ## betaPhi
  predictorsBetaPhi <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    cohort = 1:toSave$nCohorts
  )
  for(i in 1:nrow(predictorsBetaPhi)){
    predictorsBetaPhi$betaPhi[i] <- mcmc$chain1[[predictorsBetaPhi[i, "iter"], 
                                                   paste0("betaPhiCohort[", predictorsBetaPhi[i, "cohort"],
                                                          "]")
                                                ]]
  }

  predictorsAll <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    cohort = 1:toSave$nCohorts,
    season = 1:toSave$nSeasons,
    flow = seq(-1.5, 1.5, flowStep)
  )
  
  preds <- predictorsAll %>%
    left_join(predictorsBetaInt) %>%
    left_join(predictorsBetaFlow) %>%
    left_join(predictorsBetaPhi) %>%
    mutate(predPhi = plogis(betaInt + betaPhi + betaFlow1 * flow + betaFlow2 * flow^2))
  
  return(preds)
}

predFlow <- getPredictionsFlow(toSave$mcmc, everyNIters = 2)

```

### Plot flow predictions
```{r}
ggplot(predFlow, aes(flow, predPhi, group = iter)) +
  geom_line(alpha = 0.025) +
  facet_grid(season ~ cohort)

# ggplot(predFlow %>% filter(season ==1, cohort == 6), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.5) +
#   facet_grid(cohort ~ season)
# 
# ggplot(predFlow %>% filter(cohort == 3), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap( ~ season)
# 
# ggplot(predFlow %>% filter(season ==1), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap(~ cohort)

```

### run model phiT_pT_cohort_flowCohort
#### Flow effects vary by cohort
```{r phiT_pT_cohort_flowCohort, cache=TRUE}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nCohorts <- nrow(unique(eh$cohorts))
  nSeasons <- nrow(unique(eh$seasons))
  
  hmm.phiT_pT_cohort_flowCohort <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    
    for (i in 1:N){
      for (t in 1:(T-1)){ # loop over time
        logit(phi[t,i]) <- 
          betaInt +
          betaPhi[t,cohort[i]] + 
          betaFlow[1,season[i],cohort[i]] * flow[i,t] +
          betaFlow[2,season[i],cohort[i]] * flow[i,t] * flow[i,t]
           # prior survival
        
        gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
        gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
        gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
        gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
        
        logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
        omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
        omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
        omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
        omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
      }
    }
    
    betaInt ~ dnorm(0,1)
    
    for (c in 1:nCohorts){
      # mean values
      betaPhiCohort[c] ~ dnorm(0,1)
      betaPCohort[c] ~ dnorm(0,1)
      for (t in 1:(T-1)){ 
        betaPhi[t,c] ~ dnorm(betaPhiCohort[c], 1)
        betaP[t,c] ~ dnorm(betaPCohort[c], 1)
      }
    }
    
    # back-transform for examining output
    for (c in 1:nCohorts){
        betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
        betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
      for (t in 1:(T-1)){ 
        betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
        betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
      }
    }
    
    for (s in 1:nSeasons){
      for (c in 1:nCohorts){
        betaFlow[1,s,c] ~ dnorm(0, 1)
        betaFlow[2,s,c] ~ dnorm(0, 1)
      }   
    }
    
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):(last[i])){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last,
                       cohort = cohort, 
                       nCohorts = nCohorts,
                       season = eh$seasons$season,
                       flow = eh$flow
                       )
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  zInitsNA <- ifelse(is.na(eh$flow), NA, 1)
  
  initialValues <- function() list(
    betaInt = rnorm(1, 0, 1),
    phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    p =   array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    z = zInitsNA,
    betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaP =   array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaPCohort =   array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaFlow = array(rnorm(2 * 4 * nCohorts, 0, 1), c(2, 4, nCohorts))
  )
  
  parametersToSave <- c("betaInt", 
                        "betaPhi", "betaP", "betaPhiCohort", "betaPCohort",
                        "betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut", 
                        "betaFlow")  
  nIter <- 20000
  nBurnin <- 10000
  nChains <- 2
  thinRate <- 5
  
  start = Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT_cohort_flowCohort, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort_flowCohort <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  
  elapsed_phiT_pT_cohort_flowCohort <- end - start
  toSave <- list(
    mcmc = mcmc.phiT_pT_cohort_flowCohort, 
    elapsed = elapsed_phiT_pT_cohort_flowCohort,
    name = "phiT_pT_cohort_flowCohort",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohort_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohort_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohort_mostRecent.RData')
}
# could consider forward algo to speed up convergence (https://oliviergimenez.github.io/banana-book/hmmcapturerecapture.html#nimble-implementation-1)

if(plotMCMCOutput) {

  #MCMCsummary(object = mcmc.phiT_pT_cohort_flow, round = 2)
  #MCMCplot(object = mcmc.phiT_pT_cohort_flow, params = "betaPhiOut")
  MCMCplot(object = toSave$mcmc, params = "betaFlow")# 
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut"),
            pdf = FALSE, 
            priors = priors)
  
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlow"),
            pdf = FALSE, 
            priors = priors)
}

# run more iterations, if necessary
# nIterAdd <- 5000
# Cmcmc$run(nIterAdd, reset = FALSE)
# more_samples <- as.matrix(Cmcmc$mvSamples)
# 
# MCMCtrace(object = more_samples,
#           #ISB = FALSE,
#           #exact = TRUE, 
#           params = c("betaFlow"),
#           pdf = FALSE, 
#           priors = priors)

```

### Get flow effect estimates
#### Flow effects vary across cohorts
```{r}
   #     betaInt +
   #     betaPhi[t,cohort[i]] + 
   #     betaFlow[1,season[i],cohort[i]] * flow[i,t] +
   #     betaFlow[2,season[i],cohort[i]] * flow[i,t] * flow[i,t]

# load current flow model
#load("C:/Users/bletcher/OneDrive - DOI/projects/westBrook-book/models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flow_2022-05-12 10.RData")

getPredictionsFlowCohort <- function(toSave, everyNIters = 10, flowStep = 0.5){

  mcmc <- toSave$mcmc
  ## betaInt
  predictorsBetaInt <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters)
  )
  for(i in 1:nrow(predictorsBetaInt)){
    predictorsBetaInt$betaInt[i] <- mcmc$chain1[[ predictorsBetaInt[i, "iter"], "betaInt" ]]
  }
  
  
  ## betaFlow
  predictorsBetaFlow <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    season = 1:toSave$nSeasons,
    cohort = 1:toSave$nCohorts
  )
  
  for(i in 1:nrow(predictorsBetaFlow)){
    predictorsBetaFlow$betaFlow1[i] <- mcmc$chain1[[predictorsBetaFlow[i, "iter"], 
                                                   paste0("betaFlow[1, ", predictorsBetaFlow[i, "season"],
                                                          ", ",           predictorsBetaFlow[i, "cohort"],
                                                          "]")
                                                  ]]
    predictorsBetaFlow$betaFlow2[i] <- mcmc$chain1[[predictorsBetaFlow[i, "iter"], 
                                                   paste0("betaFlow[2, ", predictorsBetaFlow[i, "season"],
                                                          ", ",           predictorsBetaFlow[i, "cohort"],
                                                          "]")
                                                  ]]
  }
  
  ## betaPhi
  predictorsBetaPhi <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    cohort = 1:toSave$nCohorts
  )
  
  # this step is very slow for some reason......
  for(i in 1:nrow(predictorsBetaPhi)){
    predictorsBetaPhi$betaPhi[i] <- mcmc$chain1[[predictorsBetaPhi[i, "iter"], 
                                                   paste0("betaPhiCohort[", predictorsBetaPhi[i, "cohort"],
                                                          "]")
                                                ]]
  }

  predictorsAll <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    cohort = 1:toSave$nCohorts,
    season = 1:toSave$nSeasons,
    flow = seq(-1.5, 1.5, flowStep)
  )
  
  preds <- predictorsAll %>%
    left_join(predictorsBetaInt) %>%
    left_join(predictorsBetaFlow) %>%
    left_join(predictorsBetaPhi) %>%
    mutate(predPhi = plogis(betaInt + betaPhi + betaFlow1 * flow + betaFlow2 * flow^2))
  
  return(preds)
}

predFlowCohort <- getPredictionsFlowCohort(toSave, everyNIters = 2)

```

### Plot flow predictions
```{r}
ggplot(predFlowCohort, aes(flow, predPhi, group = iter)) +
  geom_line(alpha = 0.025) +
  facet_grid(season ~ cohort)

# ggplot(predFlowCohort %>% filter(season ==1, cohort == 6), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.5) +
#   facet_grid(cohort ~ season)
# 
# ggplot(predFlowCohort %>% filter(cohort == 3), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap( ~ season)
# 
# ggplot(predFlowCohort %>% filter(season ==1), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap(~ cohort)

```

### run model phiT_pT_cohort_flowCohortHier
#### Flow effects vary by cohort, hierarchical across cohorts
```{r phiT_pT_cohort_flowCohortHier, cache=TRUE}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nCohorts <- nrow(unique(eh$cohorts))
  nSeasons <- nrow(unique(eh$seasons))
  
  hmm.phiT_pT_cohort_flowCohortHier <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    
    for (i in 1:N){
      for (t in 1:(T-1)){ # loop over time
        logit(phi[t,i]) <- 
          betaInt +
          betaPhi[t,cohort[i]] + 
          betaFlow[1,season[i],cohort[i]] * flow[i,t] +
          betaFlow[2,season[i],cohort[i]] * flow[i,t] * flow[i,t]
           # prior survival
        
        gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
        gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
        gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
        gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
        
        logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
        omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
        omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
        omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
        omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
      }
    }
    
    betaInt ~ dnorm(0,1)
    betaFlowTop[1] ~ dnorm(0,1)
    betaFlowTop[2] ~ dnorm(0,1)
    
    for (c in 1:nCohorts){
      # mean values
      betaPhiCohort[c] ~ dnorm(0,1)
      betaPCohort[c] ~ dnorm(0,1)
      betaFlowCohort[1,c] ~ dnorm(betaFlowTop[1],1)
      betaFlowCohort[2,c] ~ dnorm(betaFlowTop[2],1)
      for (t in 1:(T-1)){ 
        betaPhi[t,c] ~ dnorm(betaPhiCohort[c],1)
        betaP[t,c] ~ dnorm(betaPCohort[c],1)
      }
    }
    
    # back-transform for examining output
    for (c in 1:nCohorts){
        betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
        betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
      for (t in 1:(T-1)){ 
        betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
        betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
      }
    }
    
    for (s in 1:nSeasons){
      for (c in 1:nCohorts){
        betaFlow[1,s,c] ~ dnorm(betaFlowCohort[1,c],1)
        betaFlow[2,s,c] ~ dnorm(betaFlowCohort[2,c],1)
      }   
    }
    
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):(last[i])){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last,
                       cohort = cohort, 
                       nCohorts = nCohorts,
                       season = eh$seasons$season,
                       flow = eh$flow
                       )
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  zInitsNA <- ifelse(is.na(eh$flow), NA, 1)
  
  initialValues <- function() list(
    betaInt = rnorm(1, 0, 1),
    phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    p =   array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    z = zInitsNA,
    betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaP =   array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaPCohort =   array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaFlow = array(rnorm(2 * 4 * nCohorts, 0, 1), c(2, 4, nCohorts)),
    betaFlowCohort = array(rnorm(2 * nCohorts, 0, 1), c(2, nCohorts)),
    betaFlowTop = rnorm(2, 0, 1)
  )
  
  parametersToSave <- c("betaInt", 
                        "betaPhi", "betaP", "betaPhiCohort", "betaPCohort",
                        "betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut", 
                        "betaFlow",
                        "betaFlowCohort", "betaFlowTop")  
  nIter <- 30000
  nBurnin <- 15000
  nChains <- 2
  thinRate <- 5
  
  start = Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT_cohort_flowCohortHier, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort_flowCohortHier <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  
  elapsed_phiT_pT_cohort_flowCohortHier <- end - start
  toSave <- list(
    mcmc = mcmc.phiT_pT_cohort_flowCohortHier, 
    elapsed = elapsed_phiT_pT_cohort_flowCohortHier,
    name = "phiT_pT_cohort_flowCohortHier",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHier_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHier_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHier_mostRecent.RData')
}
# could consider forward algo to speed up convergence (https://oliviergimenez.github.io/banana-book/hmmcapturerecapture.html#nimble-implementation-1)

if(plotMCMCOutput) {

  #MCMCsummary(object = mcmc.phiT_pT_cohort_flowHier, round = 2)
  #MCMCplot(object = mcmc.phiT_pT_cohort_flowHier, params = "betaPhiOut")
  MCMCplot(object = toSave$mcmc, params = "betaFlow")# 
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaFlowCohort"))
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut"),
            pdf = FALSE, 
            priors = priors)
  
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlow"),
            pdf = FALSE, 
            priors = priors)
}

# run more iterations, if necessary
# nIterAdd <- 5000
# Cmcmc$run(nIterAdd, reset = FALSE)
# more_samples <- as.matrix(Cmcmc$mvSamples)
# 
# MCMCtrace(object = more_samples,
#           #ISB = FALSE,
#           #exact = TRUE, 
#           params = c("betaFlow"),
#           pdf = FALSE, 
#           priors = priors)

```

### Get flow effect estimates
#### Flow effects vary across cohorts - hierarchical
```{r}
   #     betaInt +
   #     betaPhi[t,cohort[i]] + 
   #     betaFlow[1,season[i],cohort[i]] * flow[i,t] +
   #     betaFlow[2,season[i],cohort[i]] * flow[i,t] * flow[i,t]

load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHier_mostRecent.RData')
predFlowCohortHier <- getPredictionsFlowCohort(toSave, everyNIters = 2)

```

### Plot flowCohortHier predictions
```{r}
ggplot(predFlowCohortHier, aes(flow, predPhi, group = iter)) +
  geom_line(alpha = 0.025) +
  facet_grid(season ~ cohort)

# ggplot(predFlowCohortHier %>% filter(season ==1, cohort == 6), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.5) +
#   facet_grid(cohort ~ season)
# 
# ggplot(predFlowCohortHier %>% filter(cohort == 3), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap( ~ season)
# 
# ggplot(predFlowCohortHier %>% filter(season ==3), aes(flow, predPhi, group = iter)) +
  # geom_line(alpha = 0.1) +
  # facet_wrap(~ cohort)

```



### Compare models
```{r compare models}

#data.frame(model = c("(phi,p)",
#                     "(phit,pt)"),
#           WAIC = c(mcmc.phi_p, 
#                    mcmc.phiT_pT))


```

