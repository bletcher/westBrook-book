--- 
title: "The West Brook Story"
author: "Ben Letcher"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
output:
  bookdown::gitbook: default
bibliography:
- book.bib
- packages.bib
biblio-style: apalike
link-citations: yes
description: This book describes accessing, cleaning, and analyzing data from the West Brook Study in western MA, USA
---

# Introduction

This book describes accessing, cleaning, and analyzing data from the West Brook Study in Whateley MA, USA.

Use `bookdown::render_book("index.Rmd", "bookdown::gitbook")` to force html book. `bookdown::preview_chapter("01-modelsYOY.Rmd", "bookdown::gitbook")` to update just one chapter (01-modelsYOY.Rmd as example here). 

Use `clean_book()` to clean up temporary files.


## The West Brook
The Ecology Section at the USGS Conte Laboratory has studied fish in the West Brook since 1997. The goal is to understand the strength and direction of drivers on fish growth, movement, reproduction and survival in the wild. We hope to provide a comprehensive understanding of fish population dynamics and ultimately individual fitness (natural selection and evolution) in the study area.  

[Interactive applications](https://pitdata.ecosheds.org/) allow exploration of the raw data.
```{r, echo = FALSE}
knitr::include_url("https://pitdata.ecosheds.org/", height = "700px")
```


<!--chapter:end:index.Rmd-->

# Get data {#getData}

```{r globalGetData, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

The server hosting the data is named osensei and is at UMass (osensei.cns.umass.edu). It can be accessed using functions in the 'getWBData' package. Use
`devtools::install_github('Conte-Ecology/westBrookData/getWBData')` to install. Most of the functions will run reconnect() to connect to the server with your username and password. Run `reconnect()` from the console to connect if necessary. Use `conDplyr` to see the list of available tables on the server. Details about the 'getWBData' package are 
[here](https://github.com/Conte-Ecology/westBrookData/blob/master/getWBData/vignettes/getWBDataTutorial.pdf).     


```{r librariesGetData, echo = FALSE}
library(getWBData)
library(tidyverse)
library(lubridate)
library(validate)
```

We have two types of databases: Environmental and fish

The environmental database contains daily mean temperature and flow data. Flow data are from a flow extension model and are not tributary-specific. Temperature data are from tributary-specific loggers.

There are four main fish databases we want to create:    
1. **cdWB_electro0** West Brook electrofishing data, 3 species (brook trout, brown trout and Atlantic salmon), tagged and untagged fish  
2. **cdWB_CMR0** West Brook electrofishing data formatted for Capture-Mark-Recapture analysis for tagged individuals  
3. **cdWB_wanding0** West Brook wanding (portable antenna) data, all tagged salmonids  
4. **cdWB_antenna0** West Brook stationary antenna data, all tagged salmonids  

The "0" at the end of these file names indicates that they are the initial files that will be wrangled in the next step (next chapter). "cd" stands for "core data".  

The `getNew_...` variables determine whether the data are retrieved from the server. Change to 'TRUE' to get a new data frame, e.g. when there are new data on the server.
```{r switchesCD}
getNew_envDataWB <- FALSE

getNew_cdWB_electro0 <- FALSE
getNew_cdWB_CMR0 <- FALSE
getNew_cdWB_wanding0 <- FALSE
getNew_cdWB_antenna0 <- FALSE

getNew_encounterHistories <- FALSE
```


<!--chapter:end:00-getData.Rmd-->

## Get environmental data {#getEnvData}

```{r globalGetEnvData, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```


```{r envData}
if(getNew_envDataWB) {
  
  reconnect()
  envDataWB <- tbl(conDplyr, "data_daily_temperature") %>% 
    collect(n = Inf) %>% 
    full_join(tbl(conDplyr, "data_flow_extension") %>% 
    collect(n = Inf), by = c("river", "date")) %>% 
    select(-source) %>% 
    rename(temperature = daily_mean_temp, flow = qPredicted) %>%
    mutate(dateDate = as_date(date),
           yday = yday(dateDate))

  save(envDataWB, file = './data/envDataWB.RData')
  
} else {
  load(file = './data/envDataWB.RData')
}
str(envDataWB)

ggplot(envDataWB, aes(date, flow)) +
  geom_point() +
  facet_wrap(~river)

ggplot(envDataWB, aes(date, temperature)) +
  geom_point(size = 0.5) +
  facet_wrap(~river)
```



need to add getting environmental data here

<!--chapter:end:00-getEnvData.Rmd-->

## Electrofishing data {#dataElectro}

This section retrieves electrofishing data, including both tagged and untagged fish. Fish were untagged if they were too small (< 60 mm, 2 g wet weight) or were captured outside of the core study area (tributaries and 47 sections of the mainstem West Brook).
```{r globalGetDataElectro, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```


```{r librariesDataElectro, echo = FALSE}
# library(devtools)
# install_github(repo = "Conte-Ecology/westBrookData", subdir = "getWBData")
library(getWBData)
library(tidyverse)
library(lubridate)
#library(validate)

# devtools::install_github('bletcher/getPrepareWBData')
library(getPrepareWBData) # this has functions for preparing West Brook data
```

### Get data
```{r cdWB_electro0}

# default values for createCoreData()
# function (sampleType = "electrofishing", baseColumns = T, 
#    columnsToAdd = NULL, includeUntagged = F, whichDrainage = "west") 

if(getNew_cdWB_electro0) {
  cdWB_electro0 <- createCoreData(
        sampleType = "electrofishing",  #"stationaryAntenna","portableAntenna"
        columnsToAdd = c("sampleNumber",
                         "river",
                         "survey",
                         "pass",
                         "observedLength",
                         "observedWeight",
                         "comments"),
        includeUntagged = TRUE,
        whichDrainage = "west"
      ) %>%
      addTagProperties(
        columnsToAdd = c("cohort",
                         "species",
                         "dateEmigrated",
                         "sex",
                         "species"
        )
      ) %>%
      dplyr::filter(species %in% c( "bkt","bnt","ats"),
                    area %in% c("trib","inside","below","above"),
                    !is.na(sampleNumber)) %>%
      addSampleProperties() %>%
      addEnvironmental()
  
  save(cdWB_electro0, file = './data/cdWB_electro0.RData')
  
} else {
  load(file = './data/cdWB_electro0.RData')
}
str(cdWB_electro0)
```

### Wrangle data


```{r globalWrangle, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

This section takes cdWB_electro0 and cleans it to create cdWB_electro.  

```{r}
reclean_cdWB_electro <- FALSE
```


```{r wrangleElectroMain, cache = TRUE}

if(reclean_cdWB_electro){
  drainage <- 'west'

  # functions in getPrepareWBData library
  cdWB_electro <- cdWB_electro0 %>%
    cleanData(drainage) %>%
    mergeSites(drainage) %>%
    addNPasses(drainage) %>%
    mutate(drainage = drainage)
  
  save(cdWB_electro, file = './data/cdWB_electro.RData')
  
} else {
  load(file = './data/cdWB_electro.RData')
}
```

### Explore data

```{r lw, cache = TRUE}

ggplot(cdWB_electro, aes(observedLength, observedWeight, color = species)) +
  geom_point(alpha = 0.1) +
  scale_x_log10() +
  scale_y_log10() +
  theme_publication() +
  facet_wrap(~ species)

lwReg <- cdWB_electro %>%
  nest_by(species) %>%
  mutate(reg = list(lm(log(observedWeight) ~ log(observedLength), data = data)))

lwReg %>% summarise(broom::tidy(reg))  
lwReg %>% summarise(broom::glance(reg))
```




<!--chapter:end:00-dataElectro.Rmd-->

## Capture-recapture data {#dataCMR}

```{r globalGetDataCMR, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```


```{r librariesDataCMR, echo = FALSE}
library(getWBData)
library(tidyverse)
library(lubridate)
library(validate)
```

### Get data
West Brook electrofishing data formatted for Capture-Mark-Recapture analysis for tagged individuals
```{r CMR}

if(getNew_cdWB_CMR0) {
  cdWB_CMR0 <- 
    createCoreData(
      sampleType = "electrofishing", #"stationaryAntenna","portableAntenna"),
      whichDrainage = "west",
      columnsToAdd =
        c("sampleNumber",
          "river",
          "riverMeter",
          "survey",
          "pass",
          'observedLength',
          'observedWeight')
    ) %>%
    addTagProperties(
      columnsToAdd = 
        c("cohort",
          "species",
          "dateEmigrated",
          "sex",
          "species")
      ) %>%
    dplyr::filter(!is.na(tag), 
                  area %in% c("trib","inside","below","above"), 
                  !is.na(sampleNumber) 
                  ) %>%
    createCmrData(maxAgeInSamples = 20, 
                  inside = F, 
                  censorDead = F, 
                  censorEmigrated = T) %>% # may want to change censorEmigrated = T to = F
    addSampleProperties() %>%
    addEnvironmental() %>%
    addKnownZ() %>%
    fillSizeLocation(size = F) #assumes fish stay in same location until observed elsewhere

  save(cdWB_CMR0, file = './data/cdWB_CMR0.RData')
  
} else {
  load(file = './data/cdWB_CMR0.RData')
}
str(cdWB_CMR0)
```

### Make encounter history file
```{r enc hist}

getEHChar <- function(d, f){ 

  encs <- d %>%
    filter(eval(f)) %>%
    arrange(sampleNumber, tag) %>%
    pivot_wider( 
      id_cols = tag, 
      names_from = sampleNumber, 
      names_prefix = "s",
      values_from = enc, 
      values_fill = 0
  )
  
  return
  encs %>%
    unite(
      all, 
      sep = "") %>%
    mutate(tag = substr(all, 1, 10),
           encHistory = substr(all, 11, nchar(all)))
}

  getEH <- function(d, f){
    enc <- d %>%
      filter(eval(f)) %>%
      arrange(sampleNumber, tag) %>%
      pivot_wider(
        id_cols = tag,
        names_from = sampleNumber,
        names_prefix = "s",
        values_from = enc,
        values_fill = 0
      )
    
    eh <- as.matrix(enc %>% select(-tag), nrow = nrow(enc), ncol = ncol(enc) - 1)
    tags <- enc %>% select(tag)
    data <- d %>%
      filter(eval(f), enc == 1) 
    
    return(list(eh = eh, tags = tags, data = data))
  }

if (getNew_encounterHistories) {

  # all fish
  ehAll <- getEH(cdWB_CMR0, TRUE)
  save(ehAll, file = './data/ehAll.RData')
  
  # brook and brown trout
  # Put filter conditions in expression()
  spp <- expression(species %in% c("bkt", "bnt"))
  ehBKTBNT <- getEH(cdWB_CMR0, spp)
  save(ehBKTBNT, file = './data/ehBKTBNT.RData')
  
  obCohort2003 <- expression(cohort == 2003, river == "wb obear")
  ehOBCohort2003 <- getEH(cdWB_CMR0, obCohort2003)
  save(ehOBCohort2003, file = './data/ehOBCohort2003.RData')
  
  
  #area inside, trib



  
}
```


### Wrangle data
```{r}

```

### Explore data
```{r}

ggplot(cdWB_CMR0 %>% filter(enc ==1), aes(year)) +
  geom_bar() +
  facet_grid(river + season ~ species)
  


```


### CMR metadata
#### adapted from https://github.com/Conte-Ecology/westBrookData/blob/master/getWBData/vignettes/westBrookDataIntro.Rmd

#### Column explanations
__tag__ PIT tag number, unique identifier, character

__cohort__ year the fish was born, assigned based on size at initial capture and size distributions of fish of known age

__detectionDate__ mostly self explanatory, but filled in for unobserved fish as the median capture date for all observed fish.

__sampleName__ An ordered identifier for sampling mostly for recognition by people who did the sampling. This is not very clean because early in the study samples were not taken at strictly seasonal intervals. sampleNumber is probably more useful and intuitive.

__sampleNumber__ A tidier identifier for samples that strictly increases by one for each season (4/yr)

__river__ River the fish was observed in. NA if the fish was not observed.

  __west brook__ The mainstem

  __wb jimmy__ Larger tributary that fish can move back and forth into from WB section 31 (Open Large from Letcher et al 2015)

  __wb mitchell__ Smaller tributary that fish can move back and forth into from WB section 35 (Open Small from Letcher et al 2015)

  __wb obear__ Smaller tributary that has a waterfall at its mouth, so fish can only move downstream into WB section 20 (Isolated Small from Letcher et al 2015)

__section__ Identifier for the 20m section that the fish was captured in. This is ordered from downstream to upstream starting at 1 within each river. 

__area__ inside = section 1:47 in the west brook, trib = tributary (not west brook), below = sections below inside sections, above = sections above the inside sections

__observedLength__ in mm

__survey__ shock = electroshocking survey

__pass__ electrofishing pass. 1 or 2 in the west brook (inside), 1 in tribs

__observedWeight__ in g wet weight

__species__  
bkt = brook trout (native, self-sustained population)  
bnt = brown trout (non-native, self-sustained population)  
ats = atlantic salmon (stocked through 2005, no reproduction)  

__dateEmigrated__ date of emigration from inside/tribs if observed to emigrate. Coded as emigrated if last observation was on PIT antenna or captured below or above 

__sex__ NA = unknown, f = female, m = male, p = precocious male (salmon only)

__enc__  
Logical, was the fish observed? (1 = yes, 0 = no)

__ageInSamples__ number of seasons since summer of the year of birth (1st summer = 0)

__sampleIndex__ sampleNumber rescaled to start at 1 and end at length(unique(sampleNumber)) for ease of looping in JAGS

__tagIndex__ ordered, unique individual identifier 1:N

__year__ of sample

__season__ 1 = spring, 2 = summer, 3 = fall, 4 = winter

__proportionSampled__ Occasionally the sample was not complete (e.g., skipped west brook but did the tributaries). This is the proportion of sections in the river of capture that were sampled.

__lagDetectionDate__ detection date lagged back one observation

__meanTemperature__ mean temperature between observation dates. If individual was not observed, median observation date for the sampling occasion was used.

__meanFlow__ mean flow between observation dates. If individual was not observed, median observation date for the sampling occasion was used.

__knownZ__ z is alive state, so this is '1' between first and last capture, and NA otherwise, unless the fish was known to be dead (e.g. tagging mortality or observed dead) in which case the value is set to '2'. There is also an option in the addKnownZ() function to useAntenna. This is useAntenna = FALSE by default, but could be set to TRUE to set knownZ to 1 up to the last antenna observation.




<!--chapter:end:00-dataCMR.Rmd-->

## Wanding data {#dataWanding}

```{r globalGetDataWanding, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```


```{r librariesDataWanding, echo = FALSE}
library(getWBData)
library(tidyverse)
library(lubridate)

```

### Get data
West Brook wanding data
```{r wanding}

if(getNew_cdWB_wanding0) {
# from wandingDataWB project in d:/ben/github/wandingData/
  cdWB_wanding0 <- createCoreData(
    sampleType = "portableAntenna",
    columnsToAdd = c("tag", 
                     "detectionDate", 
                     "river", 
                     "area", 
                     "section", 
                     "survey", 
                     "sampleName", 
                     "readerId", 
                     "aliveOrDead", 
                     "instance", 
                     "pass", 
                     "quarter", 
                     "leftOrRight", 
                     "habitat", 
                     "cover", 
                     "justification", 
                     "comment")
    ) %>% 
    addTagProperties() %>%
    dplyr::filter( species %in% c( "bkt","bnt","ats" ) )
  
    save(cdWB_wanding0, file = './data/cdWB_wanding0.RData')
    
  } else {
    load(file = './data/cdWB_wanding0.RData')
  }
str(cdWB_wanding0)
```

### Wrangle data

### Explore data


<!--chapter:end:00-dataWanding.Rmd-->

## Antenna data {#dataAntenna}

```{r globalGetDataAntenna, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```


```{r librariesDataAntenna, echo = FALSE}
library(getWBData)
library(tidyverse)
library(lubridate)
library(validate)
```

### Get data
West Brook antenna data
Note: some pitAntenna code at https://github.com/bletcher/pitAntenna/blob/master/WB/getAndPrepareDataWB.R
```{r stationary antenna}

if(getNew_cdWB_antenna0) {
  cdWB_antenna0 <- createCoreData(
    sampleType=c("stationaryAntenna"), 
    whichDrainage = "west",
    columnsToAdd=c(
      "river",
      "riverMeter",
      "survey",
      "readerID",
      "comment"
      )
  ) %>%  
  filter(!is.na(tag)) %>% # for now
  addTagProperties(columnsToAdd = c(
    "cohort",
    "species",
    "dateEmigrated",
    "sex",
    "species")
  )
  
  save(cdWB_antenna0, file = './data/cdWB_antenna0.RData')
    
} else {
  load(file = './data/cdWB_antenna0.RData')
}

str(cdWB_antenna0)

```

### Wrangle data

### Explore data


<!--chapter:end:00-dataAntenna.Rmd-->

# Models {#models}

```{r global Models, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```


```{r librariesModels, echo = FALSE}
library(getWBData)
library(tidyverse)
library(lubridate)
library(validate)

# devtools::install_github('bletcher/getPrepareWBData')
library(getPrepareWBData) # this has functions for preparing West Brook data
```

List of models will go here



<!--chapter:end:01-models.Rmd-->

## Young-of-year size model {#modelYOY}

```{r globalModelsYOY, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```


```{r librariesModelsYOY, echo = FALSE}
library(getWBData)
library(tidyverse)
library(lubridate)
library(kableExtra)

```

The question here is what is driving _body size variation_ across years in brook trout and brown trout in the WB?  

We focus on ageInSamples == 1 (age-0 fish in the fall sample) fish for growth model. This is the first sampling occasion that most fish are big enough to tag. Not all fish are big enough, however, and there is a number of untagged fish each year. We need to include both tagged and untagged fish in our age-0 size model.

Factors to include in the model are   
1. Sample date  
2. Cumulative temperature prior to sampling  
3. Cumulative flow prior to sampling  
4. Extreme flow events?? Floods, droughts?  
5. Fish density, age-0 counts across all three salmonids  

### Raw data for YOY model
1. Environmental data (flow, temperature) are from 1, 3, or 5 months prior to date of individual capture. Also can used fixed dates: assumed spawning dates, assumed emergence dates and actual observation (sample) dates.
2. All fish data are from age-0 in autumn.
3. Abundance data.

### Get environmental data

West Brook environmental data (flow and temperature)
```{r envDataWB, cache = TRUE}
load(file = './data/envDataWB.RData')

```


### Get first observations

1. Filter cdWB_electro for first observations in the autumn for age-0 fish (ageInsamples == 1). Including both tagged and untagged fish.
```{r firstObs0}
selectedVariables <- c("tag", "species", "river", "detectionDate", "sampleNumber", "n", "proportionSampled", "observedLength", "observedWeight", "area", "section", "season", "isYOY")

firstObs_noTag <- cdWB_electro %>%
  filter(is.na(tag), ageInSamples == 1) %>%
  mutate(n = 1) %>%
  dplyr:: select(all_of(selectedVariables)) 

firstObs_tag <- cdWB_electro %>%
  group_by(tag) %>%
  mutate(isFirstObs = detectionDate == min(detectionDate),
         n = n()) %>%
  filter(isFirstObs, ageInSamples == 1) %>%
  dplyr::select(all_of(selectedVariables)) %>%
  ungroup()

firstObs0 <- add_row(firstObs_tag, firstObs_noTag) %>%
  mutate(date = as_date(detectionDate),
         yday = yday(date),
         year = year(date))

```


For each date in firstObs0 that at least one fish was captured, calculate summary stats for flow and temperature for different time periods:   
1. Assumed spawning to capture  
2. Assumed spawning to assumed emergence  
3. Assumed emergence to capture  
4. One month preceding capture  
5. Three months preceding capture  
5. Five months preceding capture


Then merge results with firstObs0 to create firstObs.
```{r firstObs}

spawn_month <- "11" # spawning
spawn_day <- "15"
emerge_month <- "03" # emergence
emerge_day <- "01"

firstObsDates <- firstObs0 %>% distinct(date = date(detectionDate), river)

# move to getPrepareWBData
getEnvMeans <- function(riverIn, start, end) { 
  out <- envDataWB %>% 
    filter(river == riverIn, dateDate >= start, dateDate <= end) %>%
    summarize(
      sumT = sum(temperature, na.rm = TRUE),
      meanT = mean(temperature, na.rm = TRUE),
      sdT = sd(temperature, na.rm = TRUE), 
      cvT = sdT/meanT,
      
      sumF = sum(flow, na.rm = TRUE),
      meanF = mean(flow, na.rm = TRUE),
      sdF = sd(flow, na.rm = TRUE),
      cvF = sdF/meanF,
      n = n()
    )

  #message(paste(river, start, end,tag))
  return(out)
}

firstObs_Env <- firstObsDates %>%
  rowwise() %>%
  mutate(
    year = year(date),
    spawnDate = ymd(paste0(year,spawn_month,spawn_day)) - years(1),
    emergeDate = ymd(paste0(year,emerge_month,emerge_day)),
    oneMonthDate = date - days(as.integer(1 * 30.5)), #months(1), 'months gives error when prev month has 30 days and current has 31
    threeMonthDate = date - days(as.integer(3 * 30.5)),
    fiveMonthDate = date - days(as.integer(5 * 30.5)),
    spawn_emerge = list(getEnvMeans(river, spawnDate, emergeDate)),
    emerge_detect = list(getEnvMeans(river, emergeDate, date)),
    spawn_detect = list(getEnvMeans(river, spawnDate, date)),
    oneMonth = list(getEnvMeans(river, oneMonthDate, date)),
    threeMonth = list(getEnvMeans(river, threeMonthDate, date)),
    fiveMonth = list(getEnvMeans(river, fiveMonthDate, date))
  )

# merge env data into firstObs0
firstObs <- firstObs0 %>%
  left_join(firstObs_Env)

#str(firstObs)
```

Unnest firstObs so environmental summary stats are available as data frame with the name of the time interval as the prefix to the statisticVariable name
```{r firstObsUnnested}

getScaled <- function(d){
  (d - mean(d, na.rm = TRUE)) / sd(d, na.rm = TRUE)
}

# this scales across all individuals - I think this is ok
firstObsUnnested <- firstObs %>% 
  unnest(cols = c(spawn_emerge, emerge_detect, spawn_detect, oneMonth, threeMonth, fiveMonth), names_sep = "_") %>%
  mutate(
    emerge_detect_sumTScaled = getScaled(emerge_detect_sumT),
    emerge_detect_sumFScaled = getScaled(emerge_detect_sumF),
    oneMonth_sumTScaled = getScaled(oneMonth_sumT),
    oneMonth_sumFScaled = getScaled(oneMonth_sumF),
    threeMonth_sumTScaled = getScaled(threeMonth_sumT),
    threeMonth_sumFScaled = getScaled(threeMonth_sumF),
    fiveMonth_sumTScaled = getScaled(fiveMonth_sumT),
    fiveMonth_sumFScaled = getScaled(fiveMonth_sumF),
    ydayScaled = getScaled(yday)
  )

str(firstObsUnnested)
#ggplot(firstObsUnnested, aes(oneMonth_sumTScaled, fiveMonth_sumTScaled)) +
#  geom_point() +
#  facet_wrap(~river)
```

### Counts of captured fish
Min and max years (inclusive) for standardizing counts
```{r minMaxYear}
minYear <- 2000
maxYear <- 2015
```

Counts by river and species
```{r rawCounts}

countsRSY <- firstObs %>%
  filter(year %in% minYear:maxYear) %>%
  group_by(river, species, year) %>%
  summarize(
    count = n(),
    meanPropSampled = mean(proportionSampled, na.rm = TRUE)
  ) %>%
  mutate(countAdj = count / meanPropSampled) %>%
  ungroup() %>%
  group_by(river, species) %>%
  mutate(meanCountRS = mean(count, na.rm = TRUE),
         sdCountRS = sd(count, na.rm = TRUE),
         countRS_Scaled = (count - meanCountRS) / sdCountRS) %>%
  ungroup()

ggplot(countsRSY, aes(year, countRS_Scaled, color = species)) +
  geom_point() +
  geom_line() +
  facet_wrap(~ river)
```

Counts by river
```{r countsRY}
countsRY <- firstObs %>%
  filter(year %in% minYear:maxYear) %>%
  group_by(river, year) %>%
  summarize(
    count = n(),
    meanPropSampled = mean(proportionSampled, na.rm = TRUE)
  ) %>%
  mutate(countAdj = count / meanPropSampled) %>%
  ungroup() %>%
  group_by(river) %>%
  mutate(meanCountR = mean(count, na.rm = TRUE),
         sdCountR = sd(count, na.rm = TRUE),
         countR_Scaled = (count - meanCountR) / sdCountR) %>%
  ungroup()

ggplot(countsRY, aes(year, countR_Scaled, color = river)) +
  geom_point() +
  geom_line()
```

Counts for the metaPopulation (WB, Jimmy, Mitchell)  
Use these for modelling.
```{r countsMeta}
countsMetaY <- firstObs %>%
  filter(river != "wb obear", year %in% minYear:maxYear) %>%
  group_by(year) %>%
  summarize(
    count = n(),
    meanPropSampled = mean(proportionSampled, na.rm = TRUE)
  ) %>%
  mutate(countAdj = count / meanPropSampled) %>%
  ungroup() %>%
  mutate(meanCount = mean(count, na.rm = TRUE),
         sdCount = sd(count, na.rm = TRUE),
         count_Scaled = (count - meanCount) / sdCount)
# missing data for tribs in 2000, 2001 - may skew scaled count a bit low - should fix

ggplot(countsMetaY, aes(year, count_Scaled)) +
  geom_point() +
  geom_line()
```

Merge metapopulation scaled counts into firstObsUnnested
```{r mergeMeta}

firstObsUnnested <- firstObsUnnested %>%
  left_join(countsMetaY %>% dplyr::select(year, count_Scaled))

firstObsUnnestedWB <- firstObsUnnested %>% filter(river == "west brook")
```


### Raw data plots

#### Frequency plots by species and river

#### Brook Trout, West brook  
```{r raw data plots1}
  #cd1 <- cdWB_electro %>% filter(ageInSamples == 1, species != 'ats')

  plotSppRiv = function(s, r) { 
    ggplot(firstObs %>% filter(species == s, river == r), aes(observedLength, color = is.na(tag))) +
      geom_freqpoly() +
      geom_vline(xintercept = 60) +
      ggtitle(paste(s, r, sep = ', ')) +
      xlim(c(30,125)) +
      facet_wrap(~ year, scales = "free_y")
  }
  
  species = 'bkt'
  riverOrdered = "west brook"

  plotSppRiv(species, riverOrdered)
```  

#### Brook Trout, wb jimmy 
```{r raw data plots2, echo = FALSE}
  species = 'bkt'
  riverOrdered = "wb jimmy"

  plotSppRiv(species, riverOrdered)
```  

#### Brook Trout, wb mitchell  
```{r raw data plots3, echo = FALSE}
  species = 'bkt'
  riverOrdered = "wb mitchell"

  plotSppRiv(species, riverOrdered)
```  

#### Brook Trout, wb obear  
```{r raw data plots4, echo = FALSE}
  species = 'bkt'
  riverOrdered = "wb obear"

  plotSppRiv(species, riverOrdered)
```  

#### Brown Trout, West brook  
```{r raw data plots5, echo = FALSE}
  species = 'bnt'
  riverOrdered = "west brook"

  plotSppRiv(species, riverOrdered)
```  

#### Brown Trout, wb jimmy 
```{r raw data plots6, echo = FALSE}
  species = 'bnt'
  riverOrdered = "wb jimmy"

  plotSppRiv(species, riverOrdered)
```  

#### Brown Trout, wb mitchell  
```{r raw data plots7, echo = FALSE}
  species = 'bnt'
  riverOrdered = "wb mitchell"

  plotSppRiv(species, riverOrdered)
```  

#### Brown Trout, wb obear - there are no Brown trout in O'Bear  

#### Trout, in the WB mainstem only
```{r troutWB}
  
  ggplot(firstObs %>% filter(species != "ats"), aes(observedLength)) +
    geom_freqpoly() +
    geom_vline(xintercept = 60, color = 'orange') +
    facet_grid(species ~ year)
  
  ggplot(firstObs %>% filter(species != "ats"), aes(observedLength, color = is.na(tag))) +
    geom_freqpoly() +
    geom_vline(xintercept = 60, color = 'orange') +
    facet_grid(species ~ year)
```
  

#### Why are there untagged fish bigger than 60mm?  
Check 2002/bkt/WB, as an example
Answer: because they are outside the study area (area = 'above' or 'below') or were tagging mortalities

```{r 2002 untagged}

  firstObs2002BKT <- firstObs %>% filter(year == 2002, species == "bkt")
  table(is.na(firstObs2002BKT$tag))
  
  ggplot(firstObs2002BKT, aes(observedLength, color = is.na(tag))) +
    geom_freqpoly() +
    geom_vline(xintercept = 60)
  
  # looks like untagged area=inside fish wee morts, the rest were above or below
  ggplot(firstObs2002BKT, aes(observedLength, color = is.na(tag))) +
    geom_freqpoly() +
    geom_vline(xintercept = 60) +
    facet_grid(~area)
  
  # check 2003
  ggplot(firstObs %>% filter(year == 2003, species == "bkt"), aes(observedLength, color = is.na(tag))) +
    geom_freqpoly() +
    geom_vline(xintercept = 60) +
    facet_grid(~area)
  # same story as 2002
```

#### Why no untagged fish for 2000 and 2001?
Check data logs to see if we were not recording untagged fish in 2000, 2001
```{r untagged 2000, 2001}

  cfirstObs2000_2001BKT <- firstObs %>% filter(year %in% 2000:2001, species == "bkt")
  table(is.na(cfirstObs2000_2001BKT$tag))
  table(cfirstObs2000_2001BKT$observedLength)

  cfirstObs2000_2001BKT %>% filter(observedLength < 60)
  
  ggplot(cfirstObs2000_2001BKT, aes(observedLength, color = is.na(tag))) +
    geom_freqpoly() +
    geom_vline(xintercept = 60)
```


### Models based on yearly means

Filter firstObsUnnestedWB for bkt, bnt and min/maxYear
```{r filter firstObsUnnestedWB}
d_WB_BKT_BNT <- firstObsUnnestedWB %>% filter(species != "ats", year %in% minYear:maxYear) %>%
  mutate(species01 = ifelse(species == "bkt", 1, 0))

hist(d_WB_BKT_BNT$detectionDate, breaks = 250)

d_BKT_BNT <- firstObsUnnested %>% filter(species != "ats", year %in% minYear:maxYear) %>%
  mutate(species01 = ifelse(species == "bkt", 1, 0))

```

Mean model functions
```{r meanModelFunctions}

getMeansData <- function(d, t, f) {
  means <- d %>% 
    group_by(species, year) %>% 
    summarize(meanLength = mean(observedLength, na.rm = TRUE), 
              meanEmerge_detect_sumTScaled = mean(emerge_detect_sumTScaled, na.rm = TRUE),
              meanEmerge_detect_sumFScaled = mean(emerge_detect_sumTScaled, na.rm = TRUE),
              meanTTime_sumTScaled = mean(get(t), na.rm = TRUE),
              meanFTime_sumFScaled = mean(get(f), na.rm = TRUE),
              meanYdayScaled = mean(ydayScaled, na.rm = TRUE),
              meanCount_Scaled = mean(count_Scaled, na.rm = TRUE)
              )
  return(means)
}

getMeansDataByRiver <- function(d, t, f) {
  means <- d %>% 
    group_by(species, year, river) %>% 
    summarize(meanLength = mean(observedLength, na.rm = TRUE), 
              meanEmerge_detect_sumTScaled = mean(emerge_detect_sumTScaled, na.rm = TRUE),
              meanEmerge_detect_sumFScaled = mean(emerge_detect_sumTScaled, na.rm = TRUE),
              meanTTime_sumTScaled = mean(get(t), na.rm = TRUE),
              meanFTime_sumFScaled = mean(get(f), na.rm = TRUE),
              meanYdayScaled = mean(ydayScaled, na.rm = TRUE),
              meanCount_Scaled = mean(count_Scaled, na.rm = TRUE)
              )
  return(means)
}

plotMeans <- function(means){
  out <- list()
  out[[1]] <- ggplot(means, aes(meanTTime_sumTScaled, meanLength, color = species)) +
    geom_point() + 
    geom_smooth(method = "lm", se = FALSE)
  
  out[[2]] <- ggplot(means, aes(meanFTime_sumFScaled, meanLength, color = species)) +
    geom_point() + 
    geom_smooth(method = "lm", se = FALSE)
  
  out[[3]] <- ggplot(means, aes(meanTTime_sumTScaled, meanFTime_sumFScaled, color = species)) +
    geom_point() + 
    geom_smooth(method = "lm", se = FALSE)
  return(out)
}

runMeanModels <- function(means) {
  modLMMeans1 <- lm(meanLength ~ (factor(species) + meanFTime_sumFScaled + meanTTime_sumTScaled + meanYdayScaled + meanCount_Scaled), data = means)
  modLMMeans2 <- lm(meanLength ~ (factor(species) + meanFTime_sumFScaled + meanTTime_sumTScaled + meanYdayScaled + meanCount_Scaled)^2, data = means)
  modLMMeans3 <- lm(meanLength ~ (factor(species) + meanFTime_sumFScaled + meanTTime_sumTScaled + meanYdayScaled + meanCount_Scaled)^3, data = means)
  return(list(modLMMeans1, modLMMeans2, modLMMeans3))
}
```

Mean lengths by river. This is information only. Using the WB data only shown here and in the next graph for the models.
```{r meanLengthsR, echo = FALSE}
means1R <- getMeansDataByRiver(d_BKT_BNT, "oneMonth_sumTScaled", "oneMonth_sumFScaled")
  ggplot(means1R, aes(year, meanLength, shape = species, color = species)) + 
    geom_point() +
    geom_line() +
    facet_wrap(~river)
```

Mean lengths for the mean length model.
```{r meanLengths, echo = FALSE}    
means1 <- getMeansData(d_WB_BKT_BNT, "oneMonth_sumTScaled", "oneMonth_sumFScaled")
  ggplot(means1, aes(year, meanLength, color = species)) + 
    geom_point() +
    geom_line()
```

Graphs for variables that do not depend on number of months
```{r staticGraphs, echo = FALSE}
  ggplot(means1, aes(meanYdayScaled, meanLength, color = species)) +
    geom_point() + 
    geom_smooth(method = "lm", se = FALSE)
  
  ggplot(means1, aes(meanCount_Scaled, meanLength, color = species)) +
    geom_point() + 
    geom_smooth(method = "lm", se = FALSE)
  
```


#### Models with flow and temperature from previous *one* month
```{r means1Month, echo = FALSE}
#means1 calculated above
plotMeans(means1)
mod1 <- runMeanModels(means1)

AIC(mod1[[1]], mod1[[2]], mod1[[3]]) %>% arrange(AIC)

summary(mod1[[1]])
rI1 <- relaimpo::calc.relimp(mod1[[1]])

save(means1, mod1, file = "models/mod1LMMeans.Rdata")
```

Relative importance for main effects model
```{r rI1, echo = FALSE}
rI1$lmg
```


#### Models with flow and temperature from previous *three* months
```{r means3Month, echo = FALSE}
means3 <- getMeansData(d_WB_BKT_BNT, "threeMonth_sumTScaled", "threeMonth_sumFScaled")
plotMeans(means3)
mod3 <- runMeanModels(means3)

AIC(mod3[[1]], mod3[[2]], mod3[[3]]) %>% arrange(AIC)

summary(mod3[[1]])

rI3 <- relaimpo::calc.relimp(mod3[[1]])

save(means3, mod3, file = "models/mod3LMMeans.Rdata")
```

Relative importance for main effects model
```{r rI3, echo = FALSE}
rI3$lmg
```


#### Models with flow and temperature from previous *five* months
```{r means5Month, echo = FALSE}
means5 <- getMeansData(d_WB_BKT_BNT, "fiveMonth_sumTScaled", "fiveMonth_sumFScaled")
plotMeans(means5)
mod5 <- runMeanModels(means5)

AIC(mod5[[1]], mod5[[2]], mod5[[3]]) %>% arrange(AIC)

summary(mod5[[1]])

rI5 <- relaimpo::calc.relimp(mod5[[1]])

save(means5, mod5, file = "models/mod5LMMeans.Rdata")
```

Relative importance for main effects model
```{r rI5, echo = FALSE}
rI5$lmg
```


r-squared values and AICs for 1st, 2nd (2-way interactions) and 3rd (3-way interactions) order models
```{r r2, echo = FALSE}
knitr::kable(
 tibble(Order = c(1,2,3),r2 = c(summary(mod1[[1]])$r.squared, summary(mod1[[2]])$r.squared, summary(mod1[[3]])$r.squared)) %>% add_column(numMonths = 1),
 digits = 3
) %>%
  kable_styling(full_width = FALSE)

knitr::kable(
 tibble(Order = c(1,2,3),r2 = c(summary(mod3[[1]])$r.squared, summary(mod3[[2]])$r.squared, summary(mod3[[3]])$r.squared)) %>% add_column(numMonths = 3),
 digits = 3
) %>%
  kable_styling(full_width = FALSE)

knitr::kable(
 tibble(Order = c(1,2,3),r2 = c(summary(mod5[[1]])$r.squared, summary(mod5[[2]])$r.squared, summary(mod5[[3]])$r.squared)) %>% add_column(numMonths = 5),
 digits = 3
) %>%
  kable_styling(full_width = FALSE)

# AIC
knitr::kable(
  format = 'html',
  AIC(mod1[[1]], mod1[[2]], mod1[[3]]) %>% arrange(AIC) %>% add_column(numMonths = 1),
  digits = 3
) %>%
  kable_styling(full_width = FALSE)

knitr::kable(
  AIC(mod3[[1]], mod3[[2]], mod3[[3]]) %>% arrange(AIC) %>% add_column(numMonths = 3),
  digits = 3
) %>%
  kable_styling(full_width = FALSE)

knitr::kable(
  AIC(mod5[[1]], mod5[[2]], mod5[[3]]) %>% arrange(AIC) %>% add_column(numMonths = 5),
  digits = 3
) %>%
  kable_styling(full_width = FALSE)

```

Relative importance of main effects models (repeat of above, but all in one place here)
```{r rIKable, echo = FALSE}
library("kableExtra")

# Relative Importance
knitr::kable(
 tibble(var = names(rI1$lmg), relImp = rI1$lmg) %>% add_column(numMonths = 1),
 digits = 3
) %>%
  kable_styling(full_width = FALSE)

knitr::kable(
 tibble(var = names(rI3$lmg), relImp = rI3$lmg) %>% add_column(numMonths = 3),
 digits = 3
) %>%
  kable_styling(full_width = FALSE)

knitr::kable(
 tibble(var = names(rI5$lmg), relImp = rI5$lmg) %>% add_column(numMonths = 5),
 digits = 3
) %>%
  kable_styling(full_width = FALSE)
```

### Models with extreme flow events (droughts)
We get negative cumulFlows because we have some negative flows from the flow extension model
```{r drought}
# put some of these calculations into envDataWB
envDataWBFlow = envDataWB %>%
  mutate(year = year(dateDate),
         yday = yday(dateDate),
         flowNoNAs = ifelse(is.na(flow), 0, flow),
         tempNoNAs = ifelse(is.na(temperature), 0, temperature)) %>%
  filter(year %in% minYear:maxYear, 
         yday > 100, yday < 300,
         river == "west brook") %>%
  group_by(year) %>%
  mutate(cumulFlow = cumsum(flowNoNAs),
         cumulFlow01 = cumulFlow / max(cumulFlow),
         cumulTemp = cumsum(tempNoNAs)) %>%
  ungroup()

firstObsYears <- firstObs %>%
    filter(year %in% minYear:maxYear, 
           yday > 100, yday < 300)

ggplot(envDataWBFlow, aes(yday, flow)) +
  geom_point(aes(yday, observedLength/20), size = 0.75, alpha = 0.2, color = 'lightblue', data = firstObsYears) +
  geom_point(size = 0.5) +
  scale_x_continuous(breaks = seq(0,300, 30)) +
  facet_wrap(~year)

ggplot(envDataWBFlow, aes(yday, cumulFlow / 10)) +
  geom_point(aes(yday, observedLength / 20), size = 0.75, alpha = 0.2, color = 'lightblue', data = firstObsYears) +
  geom_point(size = 0.5, color = 'darkgrey') +
  geom_point(aes(yday, cumulTemp / 800), size = 0.5, color = "orange", data = envDataWBFlow) +
  geom_point(aes(yday, flow), size = 0.5, data = envDataWBFlow) +
  scale_x_continuous(breaks = seq(0, 300, 30)) +
  #theme_publication() +
  facet_wrap(~year)

ggplot(envDataWBFlow, aes(yday, cumulFlow, color = (year))) +
  geom_point() +
  scale_x_continuous(breaks = seq(0, 300, 30)) 

ggplot(envDataWBFlow, aes(yday, cumulTemp, color = (year))) +
  geom_point() +
  #geom_point(aes(yday, cumulTemp / 800, color = factor(year)), data = tmp) +
  scale_x_continuous(breaks = seq(0, 300, 30))

```

Is there a sampling section effect?

Note: there are fish in sections > 50 for years 2002 and 2003, need to filter out early
```{r}
ggplot(d_WB_BKT_BNT %>% filter( section <= 47), aes(factor(section), observedLength)) +
  geom_boxplot() +
  geom_smooth() +
  facet_wrap(~year)

ggplot(d_WB_BKT_BNT %>% filter( section <= 47), aes(factor(year), observedLength)) +
  geom_boxplot() +
  geom_smooth() +
  facet_wrap(~section)
```

### Models based on individual observations
Probably not use these, too much individual variation


#### Are flow and temperature correlated for individual observations?
```{r flowTempCor, cache = TRUE}

ggplot(firstObsUnnestedWB, aes(oneMonth_sumTScaled, oneMonth_sumFScaled)) +
  geom_point(aes(color = (year))) +
  geom_smooth(method = "lm") +
  facet_wrap(~ species)

ggplot(firstObsUnnestedWB, aes(threeMonth_sumTScaled, threeMonth_sumFScaled)) +
  geom_point(aes(color = (year))) +
  geom_smooth(method = "lm") +
  facet_wrap(~ species)

ggplot(firstObsUnnestedWB, aes(fiveMonth_sumTScaled, fiveMonth_sumFScaled)) +
  geom_point(aes(color = (year))) +
  geom_smooth(method = "lm") +
  facet_wrap(~ species)

# water getting warmer during a sample
ggplot(firstObsUnnestedWB, aes(fiveMonth_sumTScaled, fiveMonth_sumFScaled)) +
  geom_point(aes(color = (yday))) +
  geom_smooth(method = "lm") +
  facet_wrap(~ species)

cor(firstObsUnnestedWB$oneMonth_sumTScaled, firstObsUnnestedWB$oneMonth_sumFScaled)
cor(firstObsUnnestedWB$threeMonth_sumTScaled, firstObsUnnestedWB$threeMonth_sumFScaled)
cor(firstObsUnnestedWB$fiveMonth_sumTScaled, firstObsUnnestedWB$fiveMonth_sumFScaled)
# brook trout
firstObsUnnestedWB_BKT <- firstObsUnnestedWB %>% filter(species == "bkt")
cor(firstObsUnnestedWB_BKT$oneMonth_sumTScaled, firstObsUnnestedWB_BKT$oneMonth_sumFScaled)
cor(firstObsUnnestedWB_BKT$threeMonth_sumTScaled, firstObsUnnestedWB_BKT$threeMonth_sumFScaled)
cor(firstObsUnnestedWB_BKT$fiveMonth_sumTScaled, firstObsUnnestedWB_BKT$fiveMonth_sumFScaled)

# brown trout
firstObsUnnestedWB_BNT <- firstObsUnnestedWB %>% filter(species == "bnt")
cor(firstObsUnnestedWB_BNT$oneMonth_sumTScaled, firstObsUnnestedWB_BNT$oneMonth_sumFScaled)
cor(firstObsUnnestedWB_BNT$threeMonth_sumTScaled, firstObsUnnestedWB_BNT$threeMonth_sumFScaled)
cor(firstObsUnnestedWB_BNT$fiveMonth_sumTScaled, firstObsUnnestedWB_BNT$fiveMonth_sumFScaled)
```

Do fish from long samples get bigger over time?  
No clear evidence.
```{r}
ggplot(firstObsUnnestedWB, aes(yday, observedLength)) +
  geom_point(alpha = 0.05) +
  geom_smooth(method = "lm") +
  facet_wrap(~year)
```


Assign the month interval (one, three, five) for flow and temperature variables. The variable will be accessed using e.g. `get(tTime)` in formulas and filters
```{r time}
tTime <- "threeMonth_sumTScaled"
fTime <- "threeMonth_sumFScaled" #"fiveMonth_sumFScaled"

```


```{r rI_LM}
library(lme4)
library(relaimpo)


modLM1 <- lm(observedLength ~ (factor(species) * get(tTime) * get(fTime) * ydayScaled * count_Scaled), data = d_WB_BKT_BNT)

modLM2 <- lm(observedLength ~ (factor(species) + get(tTime) + get(fTime) + ydayScaled + count_Scaled), data = d_WB_BKT_BNT)

modLM3 <- lm(observedLength ~ (factor(species) + get(tTime) + get(fTime) + ydayScaled + count_Scaled)^2, data = d_WB_BKT_BNT)

modLM1a <- lm(observedLength ~ (factor(species)), data = d_WB_BKT_BNT)
modLM1b <- lm(observedLength ~ (factor(species) * get(tTime)), data = d_WB_BKT_BNT)
modLM1c <- lm(observedLength ~ (factor(species) * get(fTime)), data = d_WB_BKT_BNT)
modLM1d <- lm(observedLength ~ (factor(species) * ydayScaled), data = d_WB_BKT_BNT)
modLM1e <- lm(observedLength ~ (factor(species) * count_Scaled), data = d_WB_BKT_BNT)

AIC(modLM1, modLM2, modLM3, modLM1a, modLM1b, modLM1c, modLM1d, modLM1e) %>% arrange(AIC)

#relaimpo::calc.relimp(modLM2) # slow for bigger models


# get 'boundary (singular)' error with model without 2-way interaction
#modLMER2 <- lmer(observedLength ~ (factor(species) + emerge_detect_sumTScaled + emerge_detect_sumFScaled + ydayScaled +count_Scaled)^2 + 1|year, data = d_WB_BKT_BNT)
```

```{r calcrelipmm}
#https://gist.github.com/BERENZ/e9b581a4b7160357934e
calc.relip.mm <- function(model,type='lmg') {
  if (!isLMM(model) & !isGLMM(model)) {
    stop('Currently supports only lmer/glmer objects', call. = FALSE)
  }
  require(lme4)
  X <- getME(model,'X')
  X <- X[,-1]
  Y <- getME(model,'y')
  s_resid <- sigma(model)
  s_effect <- getME(model,'theta')*s_resid
  s2 <- sum(s_resid^2,s_effect^2)
  V <- Diagonal(x = s2,n=nrow(X))
  YX <- cbind(Y,X)
  cov_XY <- solve( t(YX) %*% solve(V) %*% as.matrix(YX))
  colnames(cov_XY) <- rownames(cov_XY) <- colnames(YX)
  importances <- calc.relimp(as.matrix(cov_XY),rela=T,type=type)
  return(importances)
}
```


```{r lmer, cache = TRUE}

#modLMER1 <- lmer(observedLength ~ (factor(species) + get(tTime)|year + get(fTime)|year + ydayScaled|year + count_Scaled|year), data = d_WB_BKT_BNT)

modLMER1 <- lmer(observedLength ~ (factor(species) * get(tTime) * get(fTime) * ydayScaled * count_Scaled) + (1|year), data = d_WB_BKT_BNT)

modLMER2 <- lmer(observedLength ~ (factor(species) + get(tTime) + get(fTime) + ydayScaled + count_Scaled) + (1|year), data = d_WB_BKT_BNT)

modLMER3 <- lmer(observedLength ~ (factor(species) + get(tTime) + get(fTime) + ydayScaled + count_Scaled)^2 + (1|year), data = d_WB_BKT_BNT)

# one-by-one
modLMER1a <- lmer(observedLength ~ (factor(species))  + (1|year), data = d_WB_BKT_BNT)
modLMER1b <- lmer(observedLength ~ (factor(species) * get(tTime))  + (1|year), data = d_WB_BKT_BNT)
modLMER1c <- lmer(observedLength ~ (factor(species) * get(fTime)) + (1|year), data = d_WB_BKT_BNT)
modLMER1d <- lmer(observedLength ~ (factor(species) * ydayScaled) + (1|year), data = d_WB_BKT_BNT)
modLMER1e <- lmer(observedLength ~ (factor(species) * count_Scaled) + (1|year), data = d_WB_BKT_BNT)

AIC(modLMER1, modLMER2, modLMER3, modLMER1a, modLMER1b, modLMER1c, modLMER1d, modLMER1e) %>% arrange(AIC)

calc.relip.mm(modLMER3)
library(MuMIn)
r.squaredGLMM(modLMER1)

summary(modLMER1)
ranef(modLMER1)
```



Raw data exploration following the models  

relaimpo::calc.relimp(modLM2) - other models are too big
                                 lmg
factor(species)          0.005339423
emerge_detect_sumTScaled 0.006883496
emerge_detect_sumFScaled 0.063450197
ydayScaled               0.012116064
count_Scaled             0.028031531
```{r plotRawInd}

ggplot(d_WB_BKT_BNT, aes(get(fTime), observedLength)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm") +
  facet_wrap(~species)

ggplot(d_WB_BKT_BNT, aes(count_Scaled, observedLength)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm") +
  facet_wrap(~species)

ggplot(d_WB_BKT_BNT, aes(ydayScaled, observedLength)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm") +
  facet_wrap(~species)

ggplot(d_WB_BKT_BNT, aes(get(tTime), observedLength)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm") +
  facet_wrap(~species)

```

<!--chapter:end:01-modelsYOY.Rmd-->

## Flow model {#modelFlow}

```{r globalModelsFlow, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```


```{r librariesModelsFlow, echo = FALSE}
library(getWBData)
library(tidyverse)
library(lubridate)
library(kableExtra)
library(GGally)
library(lme4)
```

```{r readInFlowData}
dataFlow <- read.csv("./dataIn/flow/EcoDrought_Continuous_MA.csv")
```

```{r filterDataFlow}
tibble(dataFlow)
table(dataFlow$Site_Name)

d <- dataFlow %>%
  filter(Site_Name %in% c("Jimmy Brook", "Mitchell Brook", "Obear Brook Lower", "West Brook 0")) %>%
  mutate(date = mdy_hm(DateTime_EST),
         site = recode(Site_Name, "Jimmy Brook" = "OL", "Mitchell Brook" = "OS", "Obear Brook Lower" = "IS", "West Brook 0" = "WB"),
         dischargeLog = log(Discharge_Hobo_cfs + 0.01))
  
  
d %>% filter(is.infinite(dischargeLog))

scaleCol <- function(d){
  return (d - mean(d, na.rm = TRUE)) / sd(d, na.rm = TRUE)
}
# hard-coded for now
dWide <- d %>% 
  pivot_wider(id_cols = date, 
              values_from = dischargeLog, 
              names_from = site
             ) %>%
  mutate(
         OLScaled = scaleCol(OL),
         ISScaled = scaleCol(IS),
         OSScaled = scaleCol(OS),
         WBScaled = scaleCol(WB),
         yday = yday(date),
         year = year(date)
        )



```

```{r flowPlots}

ggplot(d, aes(date, dischargeLog, color = Site_Name)) +
  geom_point(size = 0.02) +
  facet_wrap(~Site_Name)

ggpairs(dWide,
          columns = 6:9,
          mapping = ggplot2::aes(color = as.factor(year), alpha = 0.7),
          #diag = list(continuous = myDens),
          lower = list(continuous = wrap("points", alpha = 0.3, size=0.1), 
                       combo = wrap("dot", alpha = 0.4, size=0.2))
        )

ggpairs(dWide %>% filter(yday > 90, yday < 300),
          columns = 6:9,
          mapping = ggplot2::aes(color = as.factor(year)),
          lower = list(continuous = wrap("points", alpha = 0.3, size=0.1), 
                       combo = wrap("dot", alpha = 0.4, size=0.2))
        )

ggpairs(dWide %>% filter(yday == 110),
          columns = 8:11,
          mapping = ggplot2::aes(color = as.factor(year)),
          lower = list(continuous = wrap("points", alpha = 0.3, size=0.2), 
                       combo = wrap("dot", alpha = 0.4, size=0.2))
        )
```

```{r flowModels}

#mod0 <- lmer(OL ~ WB * yday + as.factor(year) + 1|yday, data = dWide)

```


<!--chapter:end:01-modelsFlow.Rmd-->

## Flow model {#modelNimble}

```{r globalModelsNimble, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```


```{r librariesModelsNimble, echo = FALSE}
library(getWBData)
library(tidyverse)
library(lubridate)
library(kableExtra)
library(GGally)
library(nimble)
library(MCMCvis)
```

### Read in data
```{r}
load('./data/ehOBCohort2003.RData')
```

### run model phi_p 
```{r phi_p, cache=TRUE}
# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html

y <- ehOBCohort2003$eh

hmm.phi_p <- nimbleCode({
  phi ~ dunif(0, 1) # prior survival
  p ~ dunif(0, 1) # prior detection
  # likelihood
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
  omega[1,2] <- p        # Pr(alive t -> detected t)
  omega[2,1] <- 1        # Pr(dead t -> non-detected t)
  omega[2,2] <- 0        # Pr(dead t -> detected t)
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
  
first <- apply(y, 1, function(x) min(which(x !=0)))

my.constants <- list(N = nrow(y), 
                     T = ncol(y), 
                     first = first)

my.data <- list(y = y + 1)

zinits <- y + 1 # non-detection -> alive
zinits[zinits == 2] <- 1 # dead -> alive
initial.values <- function() list(phi = runif(1,0,1),
                                  p = runif(1,0,1),
                                  z = zinits)


parameters.to.save <- c("phi", "p", "z")  
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2

start <- Sys.time()
mcmc.phi_p <- nimbleMCMC(code = hmm.phi_p, 
                        constants = my.constants,
                        data = my.data,              
                        inits = initial.values,
                        monitors = parameters.to.save,
                        niter = n.iter, 
                        nburnin = n.burnin, 
                        nchains = n.chains,
                        WAIC = TRUE)
end <- Sys.time()
elapsed_phi_p <- end - start

MCMCsummary(object = mcmc.phi_p, round = 2)
MCMCplot(object = mcmc.phi_p)

priors <- runif(3000, 0, 1)
MCMCtrace(object = mcmc.phi_p,
          ISB = FALSE,
          exact = TRUE, 
          params = c("phi", "p"),
          pdf = FALSE, 
          priors = priors)

```

### run model phiT_pT 
```{r phiT_pT, cache=TRUE}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html

y <- ehOBCohort2003$eh

hmm.phiT_pT <- nimbleCode({
  delta[1] <- 1                    # Pr(alive t = 1) = 1
  delta[2] <- 0                    # Pr(dead t = 1) = 0
  for (t in 1:(T-1)){ # loop over time
    phi[t] ~ dunif(0, 1)           # prior survival
    gamma[1,1,t] <- phi[t]         # Pr(alive t -> alive t+1)
    gamma[1,2,t] <- 1 - phi[t]     # Pr(alive t -> dead t+1)
    gamma[2,1,t] <- 0              # Pr(dead t -> alive t+1)
    gamma[2,2,t] <- 1              # Pr(dead t -> dead t+1)
    p[t] ~ dunif(0, 1)             # prior detection
    omega[1,1,t] <- 1 - p[t]       # Pr(alive t -> non-detected t)
    omega[1,2,t] <- p[t]           # Pr(alive t -> detected t)
    omega[2,1,t] <- 1              # Pr(dead t -> non-detected t)
    omega[2,2,t] <- 0              # Pr(dead t -> detected t)
  }
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1])
    }
  }
})
  
first <- apply(y, 1, function(x) min(which(x !=0)))

my.constants <- list(N = nrow(y), 
                     T = ncol(y), 
                     first = first)

my.data <- list(y = y + 1)

zinits <- y + 1 # non-detection -> alive
zinits[zinits == 2] <- 1 # dead -> alive

initial.values <- function() list(phi = runif(my.constants$T-1,0,1),
                                  p = runif(my.constants$T-1,0,1),
                                  z = zinits)

parameters.to.save <- c("phi", "p", "z")  
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2

start <- Sys.time()
mcmc.phiT_pT <- nimbleMCMC(code = hmm.phiT_pT, 
                          constants = my.constants,
                          data = my.data,              
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter, 
                          nburnin = n.burnin, 
                          nchains = n.chains,
                          WAIC = TRUE)
end <- Sys.time()
elapsed_phiT_pT <- end - start


MCMCsummary(object = mcmc.phiT_pT, round = 2)
MCMCplot(object = mcmc.phiT_pT)

priors <- runif(n.iter, 0, 1)
MCMCtrace(object = mcmc.phiT_pT,
          ISB = FALSE,
          exact = TRUE, 
          params = c("phi"),
          pdf = FALSE, 
          priors = priors)


```


### Compare models
```{r compare models}

data.frame(model = c("(phi,p)",
                     "(phit,pt)"),
           WAIC = c(mcmc.phi_p, 
                    mcmc.phiT_pT))


```


<!--chapter:end:01-modelsNimble.Rmd-->

# Final Words

We have finished a nice book.

<!--chapter:end:06-summary.Rmd-->

`r if (knitr::is_html_output()) '
# References {-}

Some references related to the West Brook study. Will need to update and sort. (From Bens Mendelay, searched for "West brook" and deleted a few refs).  

Grader, M., and Letcher, B. 2006. Diel and seasonal gut fullness and prey composition of Atlantic salmon parr in the west brook. J. Freshw. Ecol. 21(3): 503–517.  

Armstrong, J.D., and Nislow, K.H. 2012. Modelling approaches for relating effects of change in river flow to populations of Atlantic salmon and brown trout. Fish. Manag. Ecol. 19(6): 527–536. doi:10.1111/j.1365-2400.2011.00835.x.  

Letcher, B.H., Dubreuil, T.L., O’Donnell, M.J., Obedzinski, M., Griswold, K., and Nislow, K.H. 2004. Long-term consequences of variation in timing and manner of fry introduction on juvenile Atlantic salmon (Salmo salar) growth, survival, and life-history expression. Can. J. Fish. Aquat. Sci. 61(12): 2288–2301. doi:10.1139/f04-214.  

Letcher, B.H., and Gries, G. 2003. Effects of life history variation on size and growth in stream-dwelling Atlantic salmon. J. Fish Biol. 62(1): 97–114. doi:10.1046/j.0022-1112.2003.00009.x.  

Xu, C.L., Letcher, B.H., and Nislow, K.H. 2010. Size-dependent survival of brook trout Salvelinus fontinalis in summer: effects of water temperature and stream flow. J. Fish Biol. 76(10): 2342–2369. doi:10.1111/j.1095-8649.2010.02619.x.  

O’Donnell, M.J., and Letcher, B.H. 2017. Implanting 8-mm passive integrated transponder tags into small Brook Trout: Effects on growth and survival in the laboratory. North Am. J. Fish. Manag. 37(3): 605–611. Taylor & Francis. doi:10.1080/02755947.2017.1307291.  

Zydlewski, G.B., Horton, G.E., Dubreuil, T.L., Letcher, B.H., Casey, S., and Zydlewski, J. 2006. Remote Monitoring of Fish in Small Streams: a unified approach using PIT tags. Fisheries 31(10): 492–502. doi:10.1577/1548-8446(2006)31[492:RMOFIS]2.0.CO;2.  

Sigourney, D.B., Letcher, B.H., Obedzinski, M., and Cunjak, R. a. 2013. Interactive effects of life history and season on size-dependent growth in juvenile Atlantic salmon. Ecol. Freshw. Fish 22(4): 495–507. doi:10.1111/eff.12042.  

Letcher, B.H., Hocking, D.J., O’Neil, K., Whiteley, A.R., Nislow, K.H., and O’Donnell, M.J. 2016. A hierarchical model of daily stream temperature using air-water temperature synchronization, autocorrelation, and time lags. PeerJ 4: e1727. doi:10.7717/peerj.1727.  

Horton, G.E., Dubreuil, T.L., and Letcher, B.H. 2007. A Model for Estimating Passive Integrated Transponder (PIT) Tag Antenna Efficiencies for Interval-Specific Emigration Rates. Trans. Am. Fish. Soc. 136(5): 1165–1176. doi:10.1577/T06-053.1.  

Bassar, R.D., Letcher, B.H., Nislow, K.H., and Whiteley, A.R. 2016. Changes in seasonal climate outpace compensatory density-dependence in eastern brook trout. Glob. Chang. Biol.: 577–593. doi:10.1111/gcb.13135.  

Letcher, B.H., Nislow, K.H., O’Donnell, M.J., Whiteley, A.R., Coombs, J.A., and Dubreuil, T.L. 2022. Cohort strength and body size in co-occurring salmonids in a small stream network: variation in space and time. Can. J. Fish. Aquat. Sci. 79(1): 133–147. doi:10.1139/cjfas-2020-0418.  

Letcher, B.H., Coombs, J. a., and Nislow, K.H. 2011. Maintenance of phenotypic variation: repeatability, heritability and size-dependent processes in a wild brook trout population. Evol. Appl. 4(4): 602–615. doi:10.1111/j.1752-4571.2011.00184.x.  

Letcher, B.H., Gries, G., and Juanes, F. 2002. Survival of Stream-Dwelling Atlantic Salmon: Effects of Life History Variation, Season, and Age. Trans. Am. Fish. Soc. 131(5): 838–854. doi:10.1577/1548-8659(2002)131<0838:SOSDAS>2.0.CO;2.  

Letcher, B.H. 2003. Life history dependent morphometric variation in stream-dwelling Atlantic salmon. Oecologia 137(4): 533–40. doi:10.1007/s00442-003-1387-0.  

Sigourney, D.B., Letcher, B.H., Obedzinski, M., and Cunjak, R.A. 2008. Size-independent growth in fishes: patterns, models and metrics. J. Fish Biol. 72(10): 2435–2455. doi:10.1111/j.1095-8649.2008.01830.x.  

Davidson, R.S., Letcher, B.H., and Nislow, K.H. 2010. Drivers of growth variation in juvenile Atlantic salmon ( Salmo salar ): an elasticity analysis approach. J. Anim. Ecol. 79(5): 1113–1121. doi:10.1111/j.1365-2656.2010.01708.x.  

Nislow, K.H., and Armstrong, J.D. 2012. Towards a life-history-based management framework for the effects of flow on juvenile salmonids in streams and rivers. Fish. Manag. Ecol. 19(6): 451–463. doi:10.1111/j.1365-2400.2011.00810.x.  

Whiteley, A.R., Coombs, J. a., Cembrola, M., O’Donnell, M.J., Hudy, M., Nislow, K.H., and Letcher, B.H. 2015. Effective number of breeders provides a link between interannual variation in stream flow and individual reproductive contribution in a stream salmonid. Mol. Ecol.: n/a-n/a. doi:10.1111/mec.13273.  

Letcher, B.H., Horton, G.E., Dubreuil, T.L., and Donnell, M.J.O. 2005. A field test of the extent of bias in selection estimates after accounting for emigration. Evol. Ecol.: 643–650.  

Pearlstein, J.H., Letcher, B.H., and Obedzinski, M. 2007. Early Discrimination of Atlantic Salmon Smolt Age: Time Course of the Relative Effectiveness of Body Size and Shape. Trans. Am. Fish. Soc. 136(6): 1622–1632. doi:10.1577/T07-010.1.  

Carlson, S.M., Hendry, A.P., and Letcher, B.H. 2004. Natural selection acting on body size , growth rate and compensatory growth : an empirical test in a wild trout population. Evol. Ecol.: 955–973.  

Letcher, B.H., Schueller, P., Bassar, R.D., Nislow, K.H., Coombs, J.A., Sakrejda, K., Morrissey, M., Sigourney, D.B., Whiteley, A.R., O’Donnell, M.J., and Dubreuil, T.L. 2015. Robust estimates of environmental effects on population vital rates: an integrated capture-recapture model of seasonal brook trout growth, survival and movement in a stream network. J. Anim. Ecol. 84(2): 337–352. doi:10.1111/1365-2656.12308.  

Carlson, S.M., Hendry, a. P., and Letcher, B.H. 2007. Growth rate differences between resident native brook trout and non-native brown trout. J. Fish Biol. 71(5): 1430–1447. doi:10.1111/j.1095-8649.2007.01615.x.  

O’Donnell, M.J., Horton, G.E., and Letcher, B.H. 2010. Use of Portable Antennas to Estimate Abundance of PIT-Tagged Fish in Small Streams: Factors Affecting Detection Probability. North Am. J. Fish. Manag. 30: 323–336. doi:10.1577/M09-008.1.  

Letcher, B.H., Nislow, K.H., Coombs, J., O’Donnell, M.J., and Dubreuil, T.L. 2007. Population response to habitat fragmentation in a stream-dwelling brook trout population. PLoS One 2(11): e1139. doi:10.1371/journal.pone.0001139.  

Carlson, S.M., and Letcher, B.H. 2003. Variation in brook and brown trout survival within and among seasons, species, and age classes. J. Fish Biol. 63(3): 780–794. doi:10.1046/j.1095-8649.2003.00191.x.  

Hendry, A.P., Letcher, B.H., and Gries, G. 2003. Estimating Natural Selection Acting on Stream-Dwelling Atlantic Salmon: Implications for the Restoration of Extirpated Populations. Conserv. Biol. 17(3): 795–805. doi:10.1046/j.1523-1739.2003.02075.x.  

Letcher, B.H., Schueller, P., Bassar, R.D., Nislow, K.H., Coombs, J. a, Sakrejda, K., Morrissey, M., Sigourney, D.B., Whiteley, A.R., O’Donnell, M.J., and Dubreuil, T.L. 2015. Robust estimates of environmental effects on population vital rates: an integrated capture-recapture model of seasonal brook trout growth, survival and movement in a stream network. J. Anim. Ecol. 84(2): 337–352. doi:10.1111/1365-2656.12308.  

Letcher, B.H., and Horton, G.E. 2008. Seasonal variation in size-dependent survival of juvenile Atlantic salmon (Salmo salar): performance of multistate capture-mark-recapture models. Can. J. Fish. Aquat. Sci. 65(8): 1649–1666. doi:10.1139/F08-083.  

Horton, G.E., Letcher, B.H., Bailey, M.M., and Kinnison, M.T. 2009. Atlantic salmon (Salmo salar) smolt production: the relative importance of survival and body growth. Can. J. Fish. Aquat. Sci. 66(3): 471–483. doi:10.1139/F09-005.  

Scace, J.G., Letcher, B.H., and Noreika, J. 2007. An Efficient Smolt Trap for Sandy and Debris-Laden Streams. North Am. J. Fish. Manag. 27(4): 1276–1286. doi:10.1577/M07-036.1.  

Gries, G., and Letcher, B.H. 2002. A Night Seining Technique for Sampling Juvenile Atlantic Salmon in Streams. North Am. J. Fish. Manag. 22(2): 595–601. doi:10.1577/1548-8675(2002)022<0595:ANSTFS>2.0.CO;2.  

Childress, E.S., and Letcher, B.H. 2017. Estimating thermal performance curves from repeated field observations. Ecology 98(5): 1377–1387. doi:10.1002/ecy.1801.  

Aubin-Horth, N., Letcher, B.H., and Hofmann, H. a. 2009. Gene-expression signatures of Atlantic salmon’s plastic life cycle. Gen. Comp. Endocrinol. 163(3): 278–84. Elsevier Inc. doi:10.1016/j.ygcen.2009.04.021.  

Childress, E.S., Nislow, K.H., Whiteley, A.R., O’Donnell, M.J., and Letcher, B.H. 2019. Daily estimates reveal fine-scale temporal and spatial variation in fish survival across a stream network. Can. J. Fish. Aquat. Sci. 76(8): 1446–1458. doi:10.1139/cjfas-2018-0191.  

Kanno, Y., Letcher, B.H., Coombs, J. a., Nislow, K.H., and Whiteley, A.R. 2014. Linking movement and reproductive history of brook trout to assess habitat connectivity in a heterogeneous stream network. Freshw. Biol. 59(1): 142–154. doi:10.1111/fwb.12254.  

Horton, G.E., Letcher, B.H., and Kendall, W.L. 2011. A Multistate Capture–Recapture Modeling Strategy to Separate True Survival from Permanent Emigration for a Passive Integrated Transponder Tagged Population of Stream Fish. Trans. Am. Fish. Soc. 140(2): 320–333. doi:10.1080/00028487.2011.567861.  

'`

<!--chapter:end:17-references.Rmd-->

